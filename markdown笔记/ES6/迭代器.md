# Iterator 的概念

1. 迭代器（Iterator）：**处理所有不同的数据结构的提供统一的访问机制的接口。**

2. Iterator 的迭代过程

（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，
**遍历器对象本质上，就是一个指针对象**。

（2）第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。

（3）第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。

（4）不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。

```javascript
//迭代器生成函数
function makeIterator(array) {
	var nextIndex = 0;
	return {    //返回遍历器对象
		next () {     //指针对象的next方法，用来移动指针。
			return nextIndex < array.length ?
				{value: array[nextIndex ++], /**done:false**/}:
				{/**value: undefined**/, done: true}
		}
	};
}

var it = makeIterator([1, 2]);
it.next();
it.next();
```

3. 由于 Iterator 只是把接口规格加到数据结构之上，所以，
**遍历器与它所遍历的那个数据结构，实际上是分开的.**

# 默认 iterator 接口

1. 使用 for...of 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。

**数据结构有 Symbol.iterator 属性 => 数据结构部署 Iterator 接口 => 数据结构可迭代（iterable）=> 可以用 for...of 循环遍历**


2. 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。

```javascript
//一个对象如果要具备可被for...of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。
class RangeIterator {
  constructor(start, stop) {
    this.value = start;
    this.stop = stop;
  }
  [Symbol.iterator]() {
    return this;
  }

  next() {
    var value = this.value;
    if (value < this.stop) {
      this.value++;
      return { value: value, done: false };
    } else {
      return { value: undefined, done: true };
    }
  }
}

function range(start, stop) {
  return new RangeIterator(start, stop);
}

for (var value of range(0, 3)) {
  console.log(value); // 0, 1, 2
}
```

3. 对于类似数组的对象部署 Iterator 接口方法：Symbol.iterator 方法直接引用数组的 Iterator 接口。

```javascript
NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
[...document.querySelectorAll("div")]; // 可以执行了
```

# 调用 Iterator 接口的场合

有一些场合会默认调用 Iterator 接口（即 Symbol.iterator 方法）

1. 解构赋值( 对数组和 set 集合 )

2. 扩展运算符

3. yield*

```js
const generator = function* () {
	yield 1;
	yield* [2, 3, 4];
	yield 5;
} 
const iterator = generator();
iterator.next(); // 多次调用一次返回 1  2  3  4  5
```

4. 由于数组的迭代会调用迭代器接口，所以任何接受数组作为参数的场合，其实都调用了迭代器接口。

- for...of

- Array.from()

- Map(), Set(), WeakMap(), WeakSet()（比如 new Map([['a',1],['b',2]])）

- Promise.all()

- Promise.race()

# 字符串的 Iterator 接口

字符串是一个类似数组的对象，也原生具有 Iterator 接口。

```javascript
var someString = "hi";
typeof someString[Symbol.iterator];
// "function"

var iterator = someString[Symbol.iterator]();

iterator.next(); // { value: "h", done: false }
iterator.next(); // { value: "i", done: false }
iterator.next(); // { value: undefined, done: true }
```

# Iterator 接口与 Generator 函数(略)

# 遍历器对象的 return()，throw()

1. return 方法的使用场合是，如果 for...of 循环提前退出（通常是因为出错，或者有 break 语句），就会调用 return 方法。

return 方法必须返回一个对象，这是 Generator 规格决定的。

```javascript
function readLineSync(file) {
  return {
    [Symbol.iterator]() {
      //接受一个文件对象作为参数，返回一个遍历器对象
      return {
        next() {
          return { done: false };
        },
        return() {
          file.close();
          return { done: true };
        }
      };
    }
  };
}

// 情况一
for (let line of readLinesSync(fileName)) {
  console.log(line);
  break;
}

// 情况二
for (let line of readLinesSync(fileName)) {
  console.log(line);
  throw new Error();
}
```

2. throw 方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。

# for...of 循环

## 数组

**for...of 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。**

```javascript
const arr = ["red", "green", "blue"];

for (let v of arr) {
  console.log(v); // red green blue
}

const obj = {};
obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);

for (let v of obj) {
  console.log(v); // red green blue
}

//for...in循环读取键名，for...of循环读取键值。
var arr = ["a", "b", "c", "d"];

for (let a in arr) {
  console.log(a); // 0 1 2 3
}

for (let a of arr) {
  console.log(a); // a b c d
}

//for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。
let arr = [3, 5, 7];
arr.foo = "hello";

for (let i in arr) {
  console.log(i); // "0", "1", "2", "foo"
}

for (let i of arr) {
  console.log(i); //  "3", "5", "7"
}
```

## Set 和 Map 结构

遍历的顺序是按照各个成员被添加进数据结构的顺序。

## 计算生成的数据结构

- entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。Map 结构的 Iterator 接口，默认就是调用 entries 方法。

- keys() 返回一个遍历器对象，用来遍历所有的键名。

- values() 返回一个遍历器对象，用来遍历所有的键值。

## 类数组对象

如字符串、DOM NodeList 对象、arguments 对象等。

```javascript
// DOM NodeList对象
let paras = document.querySelectorAll("p");

for (let p of paras) {
  p.classList.add("test");
}

//对于字符串来说，for...of循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。
for (let x of "a\uD83D\uDC0A") {
  console.log(x);
}
// 'a'
// '\uD83D\uDC0A'
```

并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用 Array.from 方法将其转为数组。

```javascript
let arrayLike = { length: 2, 0: "a", 1: "b" };

// 报错
for (let x of arrayLike) {
  console.log(x);
}

// 正确
for (let x of Array.from(arrayLike)) {
  console.log(x);
}
```

## 对象

对于普通的对象，for...in 循环可以遍历键名，for...of 循环会报错。

解决方法：使用 Object.keys 方法将对象的键名生成一个数组；
使用 Generator 函数将对象重新包装一下。

## 与其他遍历语法的比较

1. 数组

for...in 循环有几个缺点：（for...in 循环主要是为遍历对象而设计的，不适用于遍历数组。）

- 数组的键名是数字，但是 for...in 循环是以字符串作为键名“0”、“1”、“2”等等。

- for...in 循环不仅遍历数字键名，**还会遍历手动添加的其他键，甚至包括原型链上的键**。

- 某些情况下，for...in 循环会以任意顺序遍历键名。

for...of 的优点：

- 有着同 for...in 一样的简洁语法，但是没有 for...in 那些缺点。

- 不同于 forEach 方法，它可以与 break、continue 和 return 配合使用。

- 提供了遍历所有数据结构的统一操作接口。
