# Set

定义：**类似于数组，成员的值都是唯一的**

## 基本用法

Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”;

```javascript
    //1. 通过add()方法向 Set 结构加入成员
    const s = new Set();

    [2,3,4,5,2,2,3].forEach(x => s.add(x));

    for(let i of s) {
        console.log(i);
    }
    //2, 3, 4, 5

    //2. 接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
    const s = new Set([2,3,4,5,3,2,2]);
    s.size  //4
    
    const s = new Set(document.querySelector('div')); 

    //3. 数组,字符串去重
    [...new Set(array)];

    [...new Set('aabbcc')].join('');

```

# Set 实例的属性和方法      

1. 实例属性

    - Set.prototype.constructor：构造函数，默认就是Set函数。

    - Set.prototype.size：返回Set实例的成员总数。

2. 操作方法

    - Set.prototype.add(value)：添加某个值，返回 Set 结构本身。

    - Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
    
    - Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。
    
    - Set.prototype.clear()：清除所有成员，没有返回值。

补充： Array.from方法可以将 Set 结构转为数组。

3. 遍历方法

    - Set.prototype.keys()：返回键名的遍历器

    - Set.prototype.values()：返回键值的遍历器

    - Set.prototype.entries()：返回键值对的遍历器
 
    - Set.prototype.forEach()：使用回调函数遍历每个成员

```javascript
    //1. Set 结构没有键名，只有键值,所以keys方法和values方法的行为完全一致。
    let colors = new Set(['red', 'green', 'blue']);
    for (let item of colors.keys()) {
        console.log(item);
    }

    for (let item of colors.values()) {
        console.log(item);
    }
    //red
    //green
    //blue

    for (let item of colors.entries()) {
        console.log(item);
    }
    // ["red", "red"]
    // ["green", "green"]
    // ["blue", "blue"]

    //Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。
    //这意味着，可以省略values方法，直接用for...of循环遍历 Set。
    Set.prototype[Symbol.iterator] === Set.prototype.values     // true

    //2. 数组的map和filter方法也可以间接用于 Set 
    let set = new Set([1, 2, 3]);
    set = new Set([...set].map(x => x * 2));

    let set = new Set([1, 2, 3, 4, 5]);
    set = new Set([...set].filter(x => (x % 2) === 0));

    //3. 很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。
    let a = new Set([1, 2, 3]);
    let b = new Set([2, 3, 4]);
    //并集
    let union = new Set([...a,...b]);
    //交集
    let intersect = new Set([...a].filter(x => !b.has(x)));
    //差集
    let different = new Set([...a].filter(x => !b.has(x)));

    //4. 在遍历操作中，同步改变原来的 Set 结构:(1)利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构;(2)利用Array.from方法。
```

# WeakSet

WeakSet 的成员只能是对象;

WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

ES6 规定 WeakSet 不可遍历。

```javascript
    const foos = new WeakSet()
    class Foo {
        constructor() {
            foos.add(this)
        }
        method () {
            if (!foos.has(this)) {
            throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');
            }
        }
    }
```
上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用 WeakSet 的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。

# Map

定义：**类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。**

## 含义和基本用法

```javascript
    const m = new Map();
    const o = {p: 'Hello World'};

    m.set(o, 'content')
    m.get(o) // "content"

    m.has(o) // true
    m.delete(o) // true
    m.has(o) // false

    //Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。
    const map = new Map([
        ['name', '张三'],
        ['title', 'Author']
    ]);

    //具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。
    const set = new Set([
        ['foo', 1],
        ['bar', 2]
    ]);
    const m1 = new Map(set);
    m1.get('foo') // 1

    const m2 = new Map([['baz', 3]]);
    const m3 = new Map(m2);
    m3.get('baz') // 3

    //如果对同一个键多次赋值，后面的值将覆盖前面的值。

    //只有对同一个对象的引用，Map 结构才将其视为同一个键
    const map = new Map();

    map.set(['a'], 555);
    map.get(['a']) // undefined
```

## 实例的属性和操作方法

1. size属性

2. Map.prototype.set(key, value)

set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。

3. Map.prototype.get(key)

get方法读取key对应的键值，如果找不到key，返回undefined。

4. Map.prototype.has(key)

has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

5. Map.prototype.delete(key)

delete方法删除某个键，返回true。如果删除失败，返回false。

6. Map.prototype.clear()

clear方法清除所有成员，没有返回值。

## 遍历方法

1. Map.prototype.keys()：返回键名的遍历器。

2. Map.prototype.values()：返回键值的遍历器。

3. Map.prototype.entries()：返回所有成员的遍历器。

4. Map.prototype.forEach()：遍历 Map 的所有成员。

```javascript
    //Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。
    map[Symbol.iterator] === map.entries    //true

    // 数组的map和filter方法也可以间接用于 Map
    const m = new Map();
    m.set('1', 'Lu boTao')
        .set('2', 'object');

    const newMap = new Map([...m].map(([k, v]) => [k * 2, '_' + v]));

    //forEach遍历
    map.forEach(function(value, key, map) {
        console.log("Key: %s, Value: %s", key, value);
    });
```

## WeakMap

WeakMap与Map的区别有两点：

1. WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。

2. 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制;助于防止内存泄漏.

```javascript
    //WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。
    const e1 = document.getElementById('foo');
    const e2 = document.getElementById('bar');
    const arr = [
        [e1, 'foo 元素'],
        [e2, 'bar 元素'],
    ];
    
    //不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放e1和e2占用的内存。
    arr[0] = null;
    arr[1] = null;
    //WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。

    //WeakMap 弱引用的只是键名，而不是键值
    const wm = new WeakMap();
    let key = {};
    let obj = {foo: 1};

    wm.set(key, obj);
    obj = null;
    wm.get(key)
    // Object {foo: 1}
```

## WeakMap 的用途

```javascript
    // DOM 节点作为键名
    let myElement = document.getElementById('logo');
    let myWeakmap = new WeakMap();

    myWeakmap.set(myElement, {timesClicked: 0});

    myElement.onclick = function() {
        let logoData = myWreakmap.get(myElement);
        logoData.timesClicked++;
    }
    //每当发生click事件，就更新一下状态。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。

    //部署私有属性
    const _counter = new WeakMap();
    const _action = new WeakMap();

    class Countdown {
        constructor(counter, action) {
            _counter.set(this, counter);
            _action.set(this, action);
        }
        dec() {
            let counter = _counter.get(this);
            if (counter < 1) return;
            counter--;
            _counter.set(this, counter);
            if (counter === 0) {
            _action.get(this)();
            }
        }
    }

    const c = new Countdown(2, () => console.log('DONE'));

    c.dec()
    c.dec()
    // DONE

```