# generator 基本概念

1. 语法上，Generator 函数是**一个状态机，封装了多个内部状态**。

2. **一个遍历器对象生成函数**。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。

3. 调用 Generator 函数后，该函数并不执行，而是一个**遍历器对象（Iterator Object）**。

4. Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。

# next() 

1. next方法可以带一个参数，该参数就会被当作**上一个yield表达式的返回值**。

2. 通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。

3. for...of 迭代 generator 函数返回的迭代器，迭代到 return 语句， 不返回 return 后的参数。

# next()、throw()、return() 的共同点

1. next()是将yield表达式替换成一个值。

2. throw()是将yield表达式替换成一个throw语句。

3. return()是将yield表达式替换成一个return语句。

# Generator 函数的this


1. Generator 函数返回一个遍历器是 Generator 函数的实例，继承了 Generator 函数的prototype对象上的方法。

# 含义与应用

1. 状态机

- 少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。

- 包含了一个状态信息，即目前是否处于暂停态( 可暂停函数执行 )

2. 异步操作的同步化表达

- 将异步操作写在 ```yield``` 里面，等到时机成熟调用 ```next()``` 往后执行。

```js
function* request() {
  const response = yield getResponse('http//url')
  console.log(response.data);
}

function getResponse(url) {
  axios(url).then( res => it.next(res))
}
const it = request();
it.next();
```

3. 部署 iterator 接口

可以手动为普通对象部署  iterator 接口

```js
function* iterEntries(obj) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    yield [key, obj[key]];
  }
}
const obj = {
  a: 1,
  b: 2,
  c: 3
}
for (const [key, value] of iterEntries(obj)) {
  console.log(key, value);
}
// a  1
// b  2 
// c  3
```

4. 作数据结构

# 协程与 Generator 函数实现

1. 协程是什么？

- 即是函数，也是线程。指多个线程协作，完成异步任务。
- 比如，```yield``` 后面是异步操作，那么整个 generator 函数 是一个**协程**，协程运行到yield就交出执行权，函数暂停执行；等到执行权返回，在执行下面代码。
- 协程实现的关键在于**如何将执行权交还 generator。**

2. 协程的实现

- generator 协程实现的特点**能交出函数的执行权**

- Thunk 函数：将一个多参数函数转化为**只接受回调函数作为参数的单参数函数**

```js
function call(name, duration, callback) {
  setTimeout(() => {
    callback && callback(name);
  }, duration);
}

// 1
const Thunk = fn => {
  return (...args) => {
    return callback => {
      return fn.call(this, ...args, callback);
    }
  }
}
// 2
const Thunk = fn => (...args) => callback => fn.call(this, ...args, callback); 
const ThunkCall = Thunk(call);
ThunkCall('zhangrun', 1000)(name => console.log(name))
```

3. 实现 generator 自执行（异步）

Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。

- 基于回调实现：yield 每一步必须是 Thunk 函数，通过 run 函数（实现递归执行next()）自执行

```js
function* callName() {
  let name1 = yield ThunkCall('ma', 1000);
  console.log(name1);
  let name2 = yield ThunkCall('zhang', 2000);
  console.log(name2);
  let name3 = yield ThunkCall('li', 3000);
  console.log(name3);
}

function run(fn) {
  const gen = fn();
  function next(data) {
    const result =  gen.next(data);
    if (!result.done) {
      result.value(next);
    } else {
      return result.value;
    }
  } 
  next();
}
run(callName)
```

- 基于Promise实现：yield 每一步必须返回 一个 Promise 对象

```js
function call(name, duration) {
  return new Promise( (resolve, reject) => {
    setTimeout(() => {
      resolve(name);
    }, duration);
  })
}
function* callName() {
  let name1 = yield call('ma', 1000);
  console.log(name1);
  let name2 = yield call('zhang', 2000);
  console.log(name2);
  let name3 = yield call('li', 3000);
  console.log(name3);
}
function run(fn) {
  const gen = fn();
  function next(data) {
    const result =  gen.next(data);
    if (! result.done) {
      result.value.then(data => next(data))
    }
  }
  next();
}
run(callName);
```

# async/await （generator的语法糖）

## 改进

1. 内置执行器，直接执行函数

2. 更好的语义

3. 适用性更广 - await 后面可以是原始值（默认转换为 resolved 的 Promise 对象）

4. 返回值是 Promise 对象 

## 实现

```js
async function fn(args) {
  // ...
}

// 等同于

function fn(args) {
  return spawn(function* () {
    // ...
  });
}

function spawn(genF) {
  return new Promise((resolve, reject) => {
    const gen = genF();
    function step(nextF) {
      let next;
      try {
        next = nextF();
      } catch(e) {
        reject(e);
      }
      if(next.done) {
        resolve(next.value);
      }
      // 考虑 value 是原始值的情况
      Promise.resolve(next.value).then(
        v => step(() => gen.next(v)), 
        e => step(() => gen.throw(e))
      });
    }
    step(() => gen.next(undefined));
  });
}
```