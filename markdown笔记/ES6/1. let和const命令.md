# let 命令

1. 基本用法

let声明的变量只在它所在的代码块有效。

for循环的计数器，很合适使用let命令。
```javascript
    var a = [];
    for (let i = 0; i < 10; i++) {
      a[i] = function () {
        console.log(i);
      };
    }
    a[6](); // 6
    //每一次循环的i其实都是一个新的变量; JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。
```



2. 不存在变量提升

let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。

3. 暂时性死区

只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
**在代码块内，使用let命令声明变量之前，该变量都是不可用的。**这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）

变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。

```javascript
    if (true) {
        // TDZ开始
        tmp = 'abc'; // ReferenceError
        console.log(tmp); // ReferenceError

        let tmp; // TDZ结束
        console.log(tmp); // undefined

        tmp = 123;
        console.log(tmp); // 123
    }

    //y还没有声明，属于“死区”
    function bar(x = y, y = 2) {
        return [x, y];
    }

    bar(); // 报错
```

4. 不允许重复声明

## 块级作用域

1. 为什么引入块级作用域？

解决问题：内层变量可能会覆盖外层变量；用来计数的循环变量泄露为全局变量

块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。

2. 块级作用域与函数声明

- ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是实际都能运行，不会报错。

- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

- 为了减轻因此产生的不兼容问题，，浏览器的实现可以不遵守上面的规定，有自己的行为方式。

    1. 允许在块级作用域内声明函数。

    2. 函数声明类似于var，即变量会提升到全局作用域或函数作用域的头部。

    3. 同时，函数声明还会提升到所在的块级作用域的头部。

```javascript
   function f() { console.log('I am outside!'); }

    (function () {
      
      if (false) {
        function f() { console.log('I am inside!'); }
      }
      f();
    }());

    //在ES5,if内声明的函数f会被提升到函数头部
    function f() { console.log("I am outside!"); }

    (function() {
      function f() { console.log("I am outside!"); }
      if(false) {       
      }
      f();
    }());


    //在ES6,理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。
    function f() { console.log('I am outside!'); }

    (function () {
        if (false) {
            // 重复声明一次函数f
            function f() { console.log('I am inside!'); }
        }
        f();
    }());

    //实际的浏览器环境
    function f() { console.log('I am outside!'); }

    (function () {
        var f  = undefined;
        if (false) {
            function f() { console.log('I am inside!'); }
        }
        f();
    }());

```

- 在块级作用域内声明函数,最好写成函数表达式。

- ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。

- 严格模式下，函数只能声明在当前作用域的顶层。

# const 命令

const声明一个只读的常量。一旦声明，常量的值就不能改变。

一旦声明变量，就必须立即初始化，不能留到以后赋值。

作用域与let命令相同：只在声明所在的块级作用域内有效；常量也是不提升，同样存在暂时性死区；与let一样不可重复声明。

- 本质：对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针。

# 顶层对象与全局属性

var命令和function命令声明的全局变量，依旧是顶层对象的属性；

let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。

```javascript
    var a = 1;
    // 如果在 Node 的 REPL 环境，可以写成 global.a
    // 或者采用通用方法，写成 this.a
    window.a // 1

    let b = 1;
    window.b // undefined
```

顶层对象globalThis

- 浏览器：window，self
- Web Worker：self
- Node：global

- this:

```javascript
    var getGlobal = function () {
        if (typeof self !== 'undefined') { return self; }
        if (typeof window !== 'undefined') { return window; }
        if (typeof global !== 'undefined') { return global; }
        throw new Error('unable to locate global object');
    };
```

# 全局变量的问题

## 词法环境

1. **作用域由词法环境实现**。包括：(1)将变量名映射到变量值的环境记录。这是作用域内变量的实际存储空间。记录中的键值对称为 bindings。(2)对 外部环境 的引用——即外部作用域环境

2. 全局对象是一个特殊的对象，它的属性就是全局变量。在浏览器中，globalThis 并不是直接指向全局对象的，而是间接指向的。

3. 对于浏览器：

- Window 全局对象，随着地址改变而改变。

- WindowProxy 代理对象，负责转发对当前Window的访问，这个对象不会改变。

globalThis 在浏览器中指向WindowProxy，在其他环境里中直接指向全局对象。

## 全局环境

全局作用域是“最外层”的作用域——它没有外层作用域。全局环境的外部环境引用值为**null。**

1. 全局环境记录使用两个环境记录来管理其中的变量：

- 对象环境记录：            bindings放在JavaScript 对象里，也就是全局对象。**const，let， class**

- 普通（声明式）环境记录：  具有自己的 bindings 存储。**var，函数声明**

- 声明式记录优先级更高。

2. 使用const或let保证全局变量声明不影响ECMAScript 和宿主平台的内置全局变量（或免受其影响）。

