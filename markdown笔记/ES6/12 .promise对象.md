# Promise的含义

Promise，简单说就是一个容器，里面保存着**某个未来才会结束的事件（通常是一个异步操作）的结果**。

从语法上说，**Promise 是一个对象，从它可以获取异步操作的消息**。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。

## 特点：

1. 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。

2. 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。

## 缺点：

1. 无法取消Promise，一旦新建它就会立即执行，无法中途取消。

2. 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。

3. 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）


# 基本用法

1. Promise对象是一个构造函数，用来生成Promise实例。

```javascript
    const promise = new Promise(function(resolve, reject) {
        // ... some code

        if (/* 异步操作成功 */){
            resolve(value);     //将异步操作的结果，作为参数传递出去
        } else {
            reject(error);      //将异步操作报出的错误，作为参数传递出去。
        }
    });
```

2. Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。

```javascript
    promise.then(function(value) {
        // success
    }, function(error) {    //可选的，不一定要提供
        // failure
    });

    function timeout(ms) {
            return new Promise((resolve, reject) => {
                setTimeout(resolve, ms, 'done');
            });
        }

    timeout(1000).then((value) => {
        console.log(value);
    });
    //先生成实例，1秒后状态resolved，再触发then方法绑定的回调函数。
```

3. Promise 新建后就会立即执行，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。

```javascript
    //异步加载图片的例子
    function loadImgAsync(url) {
        return new Promise(function (resolve, reject) {
            const image = new Image();
            image.onload = function () {
                resolve(image);
            };
            image.onerror = function () {
                reject(new Error('Could not load image at ' + url));
            }
            image.src = url;
        });
    }
```

4. resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例;

```javascript
    //p1的状态传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。
    const p1 = new Promise(function (resolve, reject) {
        setTimeout(() => reject(new Error('fail')), 3000);
    })

    const p2 = new Promise(function (resolve, reject) {
        setTimeout(() => resolve(p1), 1000);
    })

    p2
    .then(result => console.log(result))
    .catch(error => console.log(error))
    // Error: fail
```

# Promise.prototype.then()      Promise.prototype.catch()

then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。

catch方法用于指定发生错误时的回调函数。

```javascript
    //Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。
    //区别:正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。
    setTimeout(function() {
        console.log(1);
    }, 0);

    new Promise(function (resolve, reject) {
        resolve(2);
        setTimeout(() => {
            console.log(4);
        }, 0);
    }).then(console.log);

    console.log(3);
    //3214
```

1. reject方法的作用，等同于抛出错误。

2. 如果 Promise 状态已经变成resolved，再抛出错误是无效的。

```javascript
    const promise = new Promise(function(resolve, reject) {
        resolve('ok');
        throw new Error('test');
    });
    promise
        .then(function(value) { console.log(value) })
        .catch(function(error) { console.log(error) });
    // ok
```

3. Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。
一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。

4. 如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。

但是，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。

```javascript
    const someAsyncThing = function() {
        return new Promise(function(resolve, reject) {
            // 下面一行会报错，因为x没有声明
            resolve(x + 2);
        });
    };

    someAsyncThing().then(function() {
        console.log('everything is great');
    });

    setTimeout(() => { console.log(123) }, 2000);
    // Uncaught (in promise) ReferenceError: x is not defined
    // 123

    const promise = new Promise(function (resolve, reject) {
        resolve('ok');
        setTimeout(function () { throw new Error('test') }, 0)
    });
    promise.then(function (value) { console.log(value) });
    // ok
    // Uncaught Error: test

    someAsyncThing()
    .catch(function(error) {
        console.log('oh no', error);
    })
    .then(function() {
        console.log('carry on');
    });
    // oh no [ReferenceError: x is not defined]
    // carry on
```
一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。

# Promise.prototype.finally()

finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。

```javascript
    Promise.prototype.finally = function (callback) {
        let P = this.constructor;
        return this.then(
            value  => P.resolve(callback()).then(() => value),
            reason => P.resolve(callback()).then(() => { throw reason })
        );
    };
```

# Promise.all()

Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。


# Promise.resolve()

有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。

```javascript
    Promise.resolve('foo')
    // 等价于
    new Promise(resolve => resolve('foo'))

    //1. 参数是一个 Promise 实例

    //2. 参数是一个thenable对象:具有then方法的对象
    let thenable = {
    then: function(resolve, reject) {
            resolve(42);
        }
    };

    let p1 = Promise.resolve(thenable);
    p1.then(function(value) {
        console.log(value);  // 42
    });

    //3. 参数不是具有then方法的对象，或根本就不是对象

    //4. 不带有任何参数
    setTimeout(function () {
        console.log('three');
    }, 0);

    Promise.resolve().then(function () {
        console.log('two');
    });

    console.log('one');

    // one
    // two
    // three
    ```