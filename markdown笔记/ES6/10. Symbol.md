# Symbol 概述

问题： 使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。

Symbol：**一种新的原始数据类型Symbol，表示独一无二的值**

Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。

```javascript
    let s1 = Symbol('foo');
    let s2 = Symbol('bar');

    typeof s1;  //"symbol"

    s1  //Symbol(foo)
    s2  //Symbol(bar)

    s1.toString()   //"Symbol(foo)"
    s2.toString()   //"Symbol(bar)"

    //1. Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。
    let s1 = Symbol();
    let s2 = Symbol();
    s1 === s2   //false

    let s3 = Symbol("foo");
    let s4 = Symbol("foo");
    s3 === s4;  //false

    //2. Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串

    //3. Symbol 值不能与其他类型的值进行运算，会报错。
    let sym = Symbol('My symbol');
    "your symbol is " + sym
    // TypeError: can't convert symbol to string
    `your symbol is ${sym}`
    // TypeError: can't convert symbol to string

    //4. Symbol 值可以显式转为字符串。
    let sym = Symbol('My symbol');
    String(sym) // 'Symbol(My symbol)'
    sym.toString() // 'Symbol(My symbol)'

    //5. Symbol 值也可以转为布尔值，但是不能转为数值。
    const sym = Symbol();
    Boolean(sym;  //true
    !sym   //false
    Number(sym);    //TypeError
```

# Symbol.prototype.description

实例属性description，直接返回 Symbol 的描述。

```javascript
    const sym = Symbol('foo');

    sym.description // "foo"
```

# 作为属性名的 Symbol

Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。

Symbol 值作为对象属性名时，不能用点运算符。

```javascript
    let MySymbol = Symbol();
    //写法一
    let a = {};
    a[MySymbol] = 'hello';
    a[MySymbol];    //"hello"

    //Symbol 值作为对象属性名时，不能用点运算符
    a.MySymbol = 'hello';
    a[MySymbol];    //undefined
    a['MySymbol'];  //"hello" 因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值

    //写法二
    Object.defineProperty(a, MySymbol, { value: 'hello' });   

    //Symbol值作为方法名
    let s = Symbol();
    let obj = {
        [s](arg) { ... }
    };

    //用于定义一组常量，保证这组常量的值都是不相等的。
    const log = {};

    log.levels = {
    DEBUG: Symbol('debug'),
    INFO: Symbol('info'),
    WARN: Symbol('warn')
    };
    console.log(log.levels.DEBUG, 'debug message');
    console.log(log.levels.INFO, 'info message');
```

# 实例：消除魔术字符串

魔术字符串：在代码之中**多次出现**、与代码形成**强耦合**的某一个具体的**字符串或者数值**。

风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。

```javascript
    //解决方案：常用的消除魔术字符串的方法，就是把它写成一个变量
    const shapeType = {
        Triangle: Symbol()
    }

    function getArea(shape,options) {
        let area = 0;
        switch (shape) {
            // case "Triangle":    //魔术字符串  
            case shapeType.Triangle:
                area = .5 * options.width * options.height;
                break;
            // ...
        }
        return area;
    }

    // let area1 = getArea('Triangle', { width: 100, height: 100 });
    let area1 = getArea(shapeType.Triangle, { width: 100, height: 100 });
```

# 属性名的遍历

Object.getOwnPropertySymbols()          Reflect.ownKeys()

# Symbol.for()，Symbol.keyFor() 

Symbol.for()接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。

```javascript
    let s1 = Symbol.for('foo');     //搜索有没有以‘foo’为参数的Symbol值，没有就创建
    let s2 = Symbol.for('foo');     //查找到有以‘foo’为参数的Symbol值，复制
    s1 === s2   //true
```
Symbol.for()与Symbol()的区别是，**前者会被登记在全局环境中供搜索**，后者不会。
Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。

Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。

Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。

```javascript
    let s1 = Symbol.for("foo");
    Symbol.keyFor(s1) // "foo"

    let s2 = Symbol("foo");
    Symbol.keyFor(s2) // undefined
   
    iframe = document.createElement('iframe');
    iframe.src = String(window.location);
    document.body.appendChild(iframe);
    iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo')   // true
```

# 内置的Symbol值

1. Symbol.hasInstance属性

指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。
比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。

```javascript
    class Even {
        static [Symbol.hasInstance](obj) {
            return Number(obj) % 2 === 0;
        }
    }

    // 等同于
    const Even = {
        [Symbol.hasInstance](obj) {
            return Number(obj) % 2 === 0;
        }
    };

    1 instanceof Even // false
    2 instanceof Even // true
    12345 instanceof Even // false
```

2. Symbol.isConcatSpreadable属性

等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。

数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。

类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。

```javascript
    class A1 extends Array {
        constructor(arg) {
            super(arg);
            this[Symbol.isConcatSpreadable] = true;
        }
    }

    class A2 extends Array {
        constructor(arg) {
            super(arg);
        }

        get [Symbol.isConcatSpreadable]() {
            return false;
        }
    }

    let a1 = new A1();
    A1[0] = 3;
    a1[1] = 4;
    let a2 = new A2();
    a2[0] = 5;
    a2[1] = 6;
    [1, 2].concat(a1).concat(a2)
    // [1, 2, 3, 4, [5, 6]]
```

3. Symbol.species属性

指向一个构造函数。创建衍生对象时，会使用该属性。

```javascript
    class MyArray extends Array {
        static get [Symbol.species]() { return Array; }
    }

    const a = new MyArray();
    const b = a.map(x => x);

    b instanceof MyArray // false
    b instanceof Array // true
```

Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。

