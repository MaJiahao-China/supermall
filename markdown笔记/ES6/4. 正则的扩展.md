# u修饰符

“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。

```javascript
    //正确返回字符串长度的函数。
    function codePointLength(text) {
        var result = text.match(/[\s\S]/ug);
        return result ? result.length : 0;
    }

```

# y修饰符

“粘连”（sticky）修饰符。

g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。

# s修饰符

“doAll”模式，点（dot）代表一切字符

# 后行断言

/(?<=y)x/ /(?<!y)x/

1. 后行断言的组匹配
```javascript
    //没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符
    
    /^(\w+)(\w+)$/.exec('NMSL');//["NMSL", "NMS", "L"]
      
     
    //“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符
    
    /(?<=(\w+)(\w+))$/.exec('NMSL');//["NMSL", "NMS", "L"]
```

2. 反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。
```javascript
    /(?<=\1n(o))r/.exec('honor'); //['r','o']
    /(?<=(o)n\1)r/.exec('honor'); //null
```

# 具名组匹配

允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。

在exec方法返回结果的groups属性上引用该组名。
```javascript
    const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/ ;
    const matchObj = RE_DATE.exec('1997-10-24');

    const year = matchObj.groups.year;  //1997
    const month = matchObj.groups.month; //10
    const day = matchObj.groups.day; //24
```

# 结构赋值和替换

```javascript
    //使用解构赋值直接从匹配结果上为变量赋值。
    let {groups:{one,two}} = /^(?<one>.*):(?<two>.*)$/.exec('foo:bar');

    //字符串替换
    let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;
    '1997-10-24'.replace(re,'$<day>/$<month>/$<year>');

    '2015-01-02'.replace(re, (
        matched, // 整个匹配结果 2015-01-02
        capture1, // 第一个组匹配 2015
        capture2, // 第二个组匹配 01
        capture3, // 第三个组匹配 02
        position, // 匹配开始的位置 0
        S, // 原字符串 2015-01-02
        groups // 具名组构成的一个对象 {year, month, day}
    ) => {
        let {day, month, year} = groups;
        return `${day}/${month}/${year}`;
    });
```

# 引用

在正则表达式内部引用某个“具名组匹配”，可以使用\k<组名>的写法。（\1）依然有效。

# String.prototype.matchAll

返回一个遍历器。
