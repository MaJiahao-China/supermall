# 函数参数的默认值

1. 基本用法

参数变量是默认声明的，所以不能用let或const再次声明。

使用参数默认值时，函数不能有同名参数。

```javascript
    //这种写法在参数是false或空格时赋值不起作用
    x = x || "默认值";

    //方法一：判断一下参数的种类
    if (typeof x === 'undefined') {
        x === '默认值';
    }

    //  ES6
    function log(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }
    const p = new log();
    p //{x : 0, y : 0};
```

2. 与结构赋值默认值结合使用

```javascript
    //不能省略第二个参数
    function fetch(url, { body = '', method = 'GET', headers = {} }) {
        console.log(method);
    }

    fetch('http://example.com', {});    //"GET"
    fetch('http://example.com');    //报错

    //可以省略第二个参数
    function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {
        console.log(method);
    }
    fetch('http://example.com');    //'GET'


    //函数参数的默认值是空对象，但是设置了对象解构赋值的默认值
    function m1({x = 0, y = 0} = {}) {
        console.log([x, y]);
    }

    m1();   //[0,0]
    m1({x : 3, y : 8});
    m1({}); //[0,0]

    //默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。
    function m2({x, y} = {x : 0, y : 0}) {
        console.log([x, y]);
    }

    m2();   //[0,0]
    m2({x : 3, y : 8});
    m2({}); //[undefined,undefined]
```

3. 函数的length属性

函数预期传入的参数个数

length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。

设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。

4. 作用域

一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域

```javascript
    //1.调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x
    var x = 1;

    function f(x,y = x) {
        console.log(y);
    }

    f(2);   //2

    //2.函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。
    let x = 1;

    function f(y = x) {
        let x = 2;
        console.log(y);
    }

    f()     //1

    //3.没有全局变量x，就会报错。

    //4.如果参数的默认值是一个函数，该函数的作用域也遵守这个规则
    var x = 1;
    function foo(x, y = function () { x = 2; }) {
        var x = 3;
        y();
        console.log(x);
    }
    foo();  //3
    x;      //1

    //函数内部没有var x = 3时
    var x = 1;
    function foo(x, y = function () { x = 2; }) {
        y();
        console.log(x);
    }
    foo();  //2
    x;      //1
```

# rest参数

（形式为...变量名），用于获取函数的多余参数；

rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错；

函数的length属性，不包括 rest 参数。

```javascript
    function sortNumbers() {
        return Array.prototype.slice.call(arguments).sort();
    }
    //用rest参数代替（rest参数本身就是数组）
    function sortNumbers(...numbers) {
        return numbers.sort();
    }

    //用rest改写push方法
    function push(array,...items) {
        items.forEach(function (item) {
            array.push(item);
            console.log(item);
        })
    }
```

# 严格模式

只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。

```javascript
    //解决方法：1.全局的严格模式；2. 立即执行函数
    //1.
    'use strict';
    function doSomething(a, b = a) {}

    //2.
    const doSomething = (function () {
        'use strict';
        return function(a, b = a)
    })();
```

# name属性

函数的name属性，返回该函数的函数名。

将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。

将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。

bind返回的函数，name属性值会加上bound前缀。

# 箭头函数

大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。

箭头函数的一个用处是简化回调函数。

1. 使用注意点

（1）**函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。**

（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。

（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。

this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。

```javascript
    //箭头函数导致this总是指向函数定义生效时所在的对象
    //可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。
    function Timer() {
        this.s1 = 0;
        this.s2 = 0;

        setInterval(() => this.s1 += 1, 1000);
        setInterval(function () {
            this.s2 += 1;
        }, 1000);
    }

    var timer = new Timer();

    setTimeout(() => console.log(timer.s1), 3100);  //3
    setTimeout(() => console.log(timer.s2), 3100);  //0

     var handler = {
        id: '123456',

        init:function  () {
            document.addEventListener('click',
                event => this.doSomething(event.type),false);
        },

        doSomething: function (type) {
            console.log('Handling ' + type  + ' for ' + this.id);
        }
    }
    handler.init();
```

除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：
arguments、super、new.target。

由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。

2. 不适用场合

定义对象的方法，且该方法内部包括this。

需要动态this的时候，也不应使用箭头函数。

# 尾调用优化

尾调用：指某个函数的最后一步是调用另一个函数。（return 一个函数）

函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。

“尾调用优化”（Tail call optimization）: 只保留内层函数的调用帧。

只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。

# 尾递归

递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

```javascript
    //递归一：阶乘
    function factorial(n) {
        if (n === 1) return 1;
        return n * factorial(n - 1);
    }

    function factorial2(n, total = 1) {
        if(n === 1) return total;
        return factorial2(n - 1, n * total);
    }

    //递归二：冯波那契数列
    function fibonacci(n) {
        if (n <= 1) return 1;
        return fibonacci(n -1) + fibonacci(n - 2);
    }

    function fibonacci2(n, ac1 = 1, ac2 = 1) {
        if(n <= 1) return ac2;
        return fibonacci2(n - 1, ac2, ac1 + ac2);
    }
```

ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。

## 尾递归的实现

正常模式下，或者那些不支持该功能的环境中，可以自己实现尾递归优化。

这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。
```javascript
    function sum(x, y) {
        if (y > 0) {
            return sum(x + 1, y - 1);
        } else {
            return x;
        }
    }

    function sum(x, y) {
        if (y > 0) {
            return sum.bind(null,x + 1, y - 1);
        } else {
            return x;
        }
    }

    //蹦床函数（trampoline）可以将递归执行转为循环执行。
    function trampoline(f) {
        while(f && f instanceof Function) {
            f = f();
        }
        return f;
    }

    //真正的尾递归优化
    function tco(fn) {
        var value;
        var active = false;
        var accumulated = [];
        return function accumulator() {
            accumulated.push(arguments);
            if (!active) {
                active = true;
                while (accumulated.length) {
                    value = fn.apply(this,accumulated.shift());
                }
                active = false;
                return value;
            }
        };
    }
```

上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。







