# 扩展运算符

1. 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。

```javascript
    function push(array, ...items) {
        array.push(...items);
    }

    function add(x, y) {
         return x + y;
    }

    const numbers = [4, 38];
    add(...numbers) // 42
```
2. 替代函数的 apply 方法

由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。

```javascript
    //数组的push方法
    var arr1 = [1,2,3];
    var arr2 = [4,5,6];
    //es5
    Array.prototype.push.apply(arr1,arr2);
    //es6
    arr1.push(...arr2);
```

3. 扩展运算符的应用

```javascript
    //1. 复制数组
    const a1 = [1, 2];
    // 写法一
    const a2 = [...a1];
    // 写法二
    const [...a2] = a1;


    //2. 合并数组(浅拷贝,都是对原数组成员的引用)
    //es5
    arr1.concat[arr2,arr3];
    //es6
    [...arr1,...arr2,...arr3];


    //3. 与解构赋值结合
    //扩展运算符可以与解构赋值结合起来，用于生成数组。
    //如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
    var list = [1,2,3,4];
    var [a,...rest] = list;
    a;  //1
    rest;   //[2,3,4]   


    //4. 字符串
    //扩展运算符还可以将字符串转为真正的数组。
    [...'hello']    //['h','e','l','l','o']
    //能够正确识别四个字节的 Unicode 字符。
    function length(str) {
        return [...str].length;
    }

    let str = 'x\uD83D\uDE80y';

    str.split('').reverse().join('')
    // 'y\uDE80\uD83Dx'

    [...str].reverse().join('')
    // 'y\uD83D\uDE80x'


    //5. 实现了 Iterator 接口的对象
    //定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。
    //NodeList对象(类数组)实现了 Iterator
    let NodeList = document.querySelectorAll('div');
    let array = [...NodeList];

    //arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。
    let arrayLike = {
        '0': 'a',
        '1': 'b',
        '2': 'c',
        'length': 3
    }
    let array = [...arrayLike];     //报错


    //6. Map 和 Set 结构，Generator 函数
```

# Array.from()

将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。

```javascript
    let arrayLike = {
            '0': 'a',
            '1': 'b',
            '2': 'c',
            'length': 3
        }
    let array1 = [].slice.call(arrayLike);  //es5
    let array2 = Array.from(arrayLike);     //es6

    //扩展运算符（...）也可以将某些数据结构转为数组。
    // arguments对象
    function foo() {
        const args = [...arguments];
    }eq

    // NodeList对象
    [...document.querySelectorAll('div')]
```
扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。
Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。
因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。


Array.from还可以接受第二个参数，作用类似于数组的map方法;

```javascript
    Array.from(arrayLike,x => x * x);
    Array.from(arrayLike).map(x => x * x);
    Array.prototype.map.call(arrayLike, x => x * x);
```

# Array.of()

将一组值，转换为数组。

弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。

```javascript
    //模拟实现
    function ArrayOf() {
        return [].slice.call(arguments);
    }
```

# 数组实例的 copyWithin()

当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。(会修改当前数组)

```javascript
    Array.prototype.copyWithin(target, start = 0, end = this.length)

    // 将3号位复制到0号位
    [1, 2, 3, 4, 5].copyWithin(0, 3, 4)
    // [4, 2, 3, 4, 5]

    // -2相当于3号位，-1相当于4号位
    [1, 2, 3, 4, 5].copyWithin(0, -2, -1)
    // [4, 2, 3, 4, 5]

    // 将3号位复制到0号位
    [].copyWithin.call({length: 5, 3: 1}, 0, 3)
    // {0: 1, 3: 1, length: 5}

    // 将2号位到数组结束，复制到0号位
    let i32a = new Int32Array([1, 2, 3, 4, 5]);
    i32a.copyWithin(0, 2);
    // Int32Array [3, 4, 5, 4, 5]

    // 对于没有部署 TypedArray 的 copyWithin 方法的平台
    // 需要采用下面的写法
    [].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
    // Int32Array [4, 2, 3, 4, 5]
```

# 数组实例的 find() 和 findIndex()

数组实例的find方法，用于找出第一个符合条件的数组成员;
它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。

findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1.

可以接受第二个参数，用来绑定回调函数的this对象.

都可以发现NaN，弥补了数组的indexOf方法的不足。

```javascript
    //返回第一个大于0的成员
    var arr = [2,6,1,0,5]; z
    arr.find((value,index,arr) => value > 0);
```

# 数组实例的 fill()

使用给定值，填充一个数组。

可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。

# 数组实例的 entries()，keys() 和 values()

遍历器 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。

```javascript
    for (let index of ['a', 'b'].keys()) {
         console.log(index);
    }
    // 0
    // 1

    for (let elem of ['a', 'b'].values()) {
        console.log(elem);
    }
    // 'a'
    // 'b'

    for (let [index, elem] of ['a', 'b'].entries()) {
        console.log(index, elem);
    }
    // 0 "a"
    // 1 "b"
```

# 数组实例的 includes()

返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。

第二个参数表示搜索的起始位置，默认为0。

# 数组实例的 flat()，flatMap()

将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组(对原数据没有影响)

参数写成一个整数，表示想要拉平的层数.

如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。

如果原数组有空位，flat()方法会跳过空位。

```javascript
    [1, 2, [3, 4]].flat()
    // [1, 2, 3, 4]

    [1, 2, [3, [4, 5]]].flat(2)
    // [1, 2, 3, 4, 5]

    [1, [2, [3]]].flat(Infinity)
    // [1, 2, 3]

    [1, 2, , 4, 5].flat()
    // [1, 2, 4, 5]
```

flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。

```javascript
    // 相当于 [[2, 4], [3, 6], [4, 8]].flat()
    [2, 3, 4].flatMap((x) => [x, x * 2])

    // 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()
    [1, 2, 3, 4].flatMap(x => [[x * 2]])
```

# 数组的空位

数组的某一个位置没有任何值(区别于undefined)；

es5:

- forEach(), filter(), reduce(), every() 和some()都会跳过空位。
- map()会跳过空位，但会保留这个值
- join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。

es6:

将空位转为undefined。

```javascript
    // forEach方法
    [,'a'].forEach((x,i) => console.log(i)); // 1

    // filter方法
    ['a',,'b'].filter(x => true) // ['a','b']

    // every方法
    [,'a'].every(x => x==='a') // true

    // reduce方法
    [1,,2].reduce((x,y) => x+y) // 3

    // some方法
    [,'a'].some(x => x !== 'a') // false

    // map方法
    [,'a'].map(x => 1) // [,1]

    // join方法
    [,'a',undefined,null].join('#') // "#a##"

    // toString方法
    [,'a',undefined,null].toString() // ",a,,"
```

数组的方法汇总：

静态方法：

- Array.from

- Array.isArray

- Array.of: 类似于括号创建数组

非纯函数：

- fill：填充数组

- pop  push

- shift unshift

- reverse：逆序

- splice：剪切

- sort： 排序Unicode码点

纯函数，无副作用函数：不会导致当前对象发生改变

- concat

- includes： 数组是否包含满足条件的元素

- join

- slice

- indexOf lastIndexOf

- forEach  map

- every :是否所有元素满足条件

- some： 是否至少有一个元素满足条件

- filter： 过滤，得到满足条件的元素组成的新数组

- find： 查找第一个满足条件的元素，返回元素本身，如果没有，返回undefined

- findIndex: 查找第一个满足条件的元素，返回下标，没有返回-1

- reduce：统计，累计



