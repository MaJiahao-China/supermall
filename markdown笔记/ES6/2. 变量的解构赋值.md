# 数组的解构赋值

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

解构赋值允许指定默认值。

ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。
```javascript
    let [x = 1] = [undefined];
    x // 1

    let [x = 1] = [null];
    x // null

    function f() {
        console.log('aaa');
    }
    let [x = f()] = [1];
```
# 对象的解构

```javascript
    let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
```
1. 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。

```javascript
    // 例一
    let { log, sin, cos } = Math;

    // 例二
    const { log } = console;
    log('hello') // hello
```
2. 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

```javascript
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };

let{ foo:bar } = { foo:"aaa", bar:"bbb" } //bar"aaa"  foo Error

```

3. 嵌套结构的对象。

```javascript
    // : 前面是模式不是变量，这里的变量是loc,start,line
    const node = {
        loc: {
            start: {
                line: "10m",
                column: "20"
            }
        }
    };
    let { loc, loc: { start }, loc: { start: { line }} } = node;
    
    // 嵌套赋值
    let obj = {};
    let arr = [];
    ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });
    
    //报错：foo这时等于undefined，再取子属性就会报错
    let{ foo:{bar}} = { baz:"baz" };
    
    //对象的解构赋值会取到继承的属性
    const obj1 = {};
    const obj2 = { foo: 'bar' };
    Object.setPrototypeOf(obj1, obj2);

    const { foo } = obj1;
    foo // "bar"
```
4. 注意点

```javascript
    //JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。
    let x ;
    {x} = { x: 1};

    //由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
    let arr = [1, 2, 3];
    let {0 : first, [arr.length - 1] : last} = arr;
    first // 1
    last // 3

```

# 字符串的解构赋值

```javascript
    //字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
    const [a,b,c,d,e] = "hello";
    //类似数组的对象都有一个length属性
    const{ length : len } = "hello";
```
解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。

由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。

# 函数参数的解构赋值

```javascript
    function add([x, y]){
        return x + y;
    }

    [[1, 2], [3, 4]].map(([a, b]) => a + b);
    
    //变量指定默认值0
    function move({x = 0, y = 0} = {}) {
        return [x, y];
    }
    move({x: 3, y: 8}); // [3, 8]
    move({x: 3}); // [3, 0]
    move({}); // [0, 0]
    move(); // [0, 0]

    //参数指定默认值0
    function move({x, y} = { x: 0, y: 0 }) {
        return [x, y];
    }
    move({x: 3, y: 8}); // [3, 8]
    move({x: 3}); // [3, undefined]
    move({}); // [undefined, undefined]
    move(); // [0, 0]
```

# 圆括号问题

只要有可能导致解构的歧义，就不得使用圆括号。建议只要有可能，就不要在模式中放置圆括号。

不能使用的情况：1. 变量声明语句；2. 函数参数；3. 赋值语句的模式
可以使用的情况：赋值语句的非模式部分

```javascript
    function f([(a)]) {}  //报错 情况2  函数参数解构也不用()

    let [(a)] = [1];   //报错 情况1  有let这些声明语句不能用()
    ([a]) = [1];  //报错 情况3
    [(a)] = [1];  //正确
```

# 用途

```javascript
    //1. 交换变量的值
    let x = 1;
    let y = 2;
    [x, y] = [y, x];

    //2. 从函数返回多个值
    function example() {
        return [1, 2, 3];
    }
    let [a, b, c] = example();

    function example() {
        return {
            foo: 1,
            bar: 2
        };
    }
    let { foo, bar } = example();

    //3. 函数参数的定义
    //参数是一组有序的数组
    function f([x,y,z]) {}
    f([1, 2, 3]);

    //参数是一组无序的值
    function f({x,y,z}) {}
    f({y: 2,z: 3,x: 1});

    //4. 提取json数据

    //5. 函数参数的默认值

    //6. 遍历map结构

    //7. 输入模块的指定方法
```