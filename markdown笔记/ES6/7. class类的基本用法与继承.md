# 简介

类的所有方法都定义在类的prototype属性上面。

类的内部所有定义的方法，都是不可枚举的（non-enumerable）。

方法之间不需要逗号分隔，加了会报错。

```javascript
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        toString() {
            return 'x:' + this.x + ' y:' + this.y;
        }
    }

    var p = new Point(1,2);

    typeof Point;  //'function'
    Point === Point.prototype.constructor;  //true

    p.constructor === Point.prototype.constructor;  //true
```

1. constructor 方法

constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。

**constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。**

类必须使用new调用，否则会报错。

2. 取值函数（getter）和存值函数（setter）

```HTML
    <div>1</div>
```  

```javascript
    var div = document.querySelector('div');

    class CustomHTMLElement {
        constructor(element) {
            this.element = element;
        }

        get html() {
            return this.element.innerHTML;
        }

        set html(value) {
            this.element.innerHTML = value;
        }
    }

    var div = new customHTMLElement(div);
    div.html    //获取div内部文本
    div.html = 2;   //设置文本为2
```

3. 属性表达式

```javascript
    let methodName = 'getArea';

    class Square {
        constructor(length) {
            // ...
        }

        [methodName]() {
            // ...
        }
    }
```

4. Class 表达式

类也可以使用表达式的形式定义

采用 Class 表达式，可以写出立即执行的 Class。

```javascript
    //这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。
    const MyClass = class Me {
        getClassName () {
            return Me.name;
        }
    };
    let inst = new MyClass();
    inst.getClassName() // Me
    Me.name // ReferenceError: Me is not defined

    let person = new class {
        constructor(name) {
            this.name = name;
        }

        sayName () {
            console.log(this.name);
        }
    }('张三');

    person.sayName();

```

5. 注意点

(1) 类和模块的内部，默认就是严格模式

(2) 不存在提升,这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。

(3) name属性总是返回紧跟在class关键字后面的类名。

(4) 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。

(5) 类的方法内部如果含有this，它默认指向类的实例。

```javascript
    class Logger {
        // constructor() {
        //     this.printName = this.printName.bind(this);
        // }

        printName(name = 'there') {
            this.print(`Hello ${name}`);
        }

        print(text) {
            console.log(text);
        }
    }

    const logger = new Logger();
    const { printName } = logger;
    printName(); // TypeError: Cannot read property 'print' of undefined
```
如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错。

# 静态方法

类相当于实例的原型，所有在类中定义的方法，都会被实例继承。

**静态方法：加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用。**

```javascript
    //1. 在实例上调用静态方法，会抛出一个错误，表示不存在该方法。
    class Foo {
        static classMethod() {
            return 'hello';
        }
    }
    Foo.classMethod();  //'hello'

    var foo = new Foo();
    foo.classMethod();  //报错

    //2. 静态方法包含this关键字，这个this指的是类，而不是实例。
    class Foo {
        static bar() {
            this.baz();
        }
        static baz() {
            console.log('hello');
        }
        baz() {
            console.log('world');
        }
    }

    Foo.bar(); //'hello'

    //3. 父类的静态方法，可以被子类继承。
    class Foo {
        static classMethod() {
            return 'hello';
        }
    }

    class Bar extends Foo {
    }

    Bar.classMethod;

    //4. 静态方法也是可以从super对象上调用的。
    class Bar extends Foo {
        static  classMethod() {
            return super.classMethod();
        }
    }
    Bar.classMethod();  //'hello'
```

# 实例属性的新写法

实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。

```javascript
    //实例属性与其他方法，处于同一个层级。这时，不需要在实例属性前面加上this。
    class Foo {
        bar = "hello";
        baz = "world";
        
        constructor() {}
    }
```

# 静态属性

现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字。  


# 私有方法，私有属性

定义：只能在类的内部访问的方法和属性，外部不能访问。

```javascript
    //一: 在命名上加以区别.
    class Widget {
        //公有方法
        foo(baz) {
            this._bar(baz);
        }
        //私有方法
        _baz(baz) {
            return this.snaf = baz;
        }
    }

    //私有方法移出模块
    class Widget {
        foo (baz) {
            bar.call(this, baz);
        }
        // ...
    }

    function bar(baz) {
        return this.snaf = baz;
    }

    //Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。
    const bar = Symbol('bar');
    const snaf = Symbol('snaf');

    export default class myClass{

        // 公有方法
        foo(baz) {
            this[bar](baz);
        }

        // 私有方法
        [bar](baz) {
            return this[snaf] = baz;
        }

        // ...
    };
    //Symbol 值的属性名依然可以从类的外部拿到。
```

## 私有属性的提案

有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。

```javascript
    class Point {
            #x;

            constructor(x = 0) {
                this.#x = +x;
            }

            get x() {
                return this.#x;
            }

            set x(value) {
                this.#x = +value;
            }
        }

    var point = new Point(1);
    point.x     //1
    point.x = 2;    //2
```

# new.target 属性

该属性一般用在构造函数之中，返回new命令作用于的那个构造函数;

如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined.

```javascript
    //确保构造函数只能通过new命令调用
    function Person(name) {
        if (new.target === Person) {
            this.name = name;
        } else {
            throw new Error('必须使用 new 命令生成实例');
        }
    }

    //Class 内部调用new.target，返回当前 Class。
    class Rectangle {
        constructor(length, width) {
            console.log(new.target === Rectangle);
            this.length = length;
            this.width = width;
        }
    }
    var obj = new Rectangle(3, 4); // 输出 true

    //子类继承父类时，new.target会返回子类。
    class  Father {
        constructor() {
            console.log(new.target === Father);
        }
    }

    class Son extends Father {
        constructor() {
            super();
        }
    }

    var son = new Son();    //输出false

    //写出不能独立使用、必须继承后才能使用的类
    class  Father {
        constructor() {
            if (new.target === Father) {
                throw new Error('本类不能实例化');
            }
        }
    }

    class Son extends Father {
        constructor() {
            super();
        }
    }

    var father = new Father();  //Error: 本类不能实例化
    var son = new Son();    
```

# Class 的继承:简介

子类必须在constructor方法中调用super方法，否则新建实例时会报错.
子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。

```javascript
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        toString() {
            return this.x + ' ' + this.y;
        }
    }

    class ColorPoint extends Point {
        constructor(x, y,color) {
            super(x, y);    //调用父类的constructor(x, y)
            this.color = color;
        }
        //只有先调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。

        toString() {
            return this.color + ' ' + super.toString(); // 调用父类的toString()
        }
    }

    //实例对象cp同时是ColorPoint和Point两个类的实例
    let cp = new ColorPoint(10,10,"green");
    cp instanceof ColorPoint;   //true
    cp instanceof Point;    //true
```

ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。

ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。

父类的静态方法，也会被子类继承.

# Object.getPrototypeOf()

用来从子类上获取父类

```javascript
    Object.getPrototypeOf(ColorPoint) === Point     // true
```

# super 关键字

super作为函数调用时，代表父类的构造函数。super()只能用在子类的构造函数之中，用在其他地方就会报错。

- super(x,y)在前面的类继承中相当于Point.prototype.constructor.call(this)。

super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

```javascript
    class A {
        A.prototype.q = 2;
        constructor() {
            this.p = 2;
        }
    }

    class B extends A {
        get m() {
            return super.p;
        }
        get n() {
            return super.q;
        }
    }

    let b = new B();
    b.m // undefined
    b.n // 2
```

this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this.

```javascript
    class A {
        constructor() {
            this.x = 1;
        }
    }

    class B extends A {
        constructor() {
            super();
            this.x = 2;
            super.x = 3;
            console.log(super.x); // undefined
            console.log(this.x); // 3
        }
    }

    let b = new B();
    //super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。
```

使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。

```javascript
    //super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。
    class A {}

    class B extends A {
        constructor() {
            super();
            console.log(super); // 报错
            console.log(super.valueOf() instanceof  B); //true
        }
    }

    //对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。
    var obj = {
        toString() {
            return "MyObject: " + super.toString();
        }
    };

    obj.toString(); // MyObject: [object Object]
```

# 类的 prototype 属性和__proto__属性

es5: 每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。


Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。

- 子类的__proto__属性，表示构造函数的继承，总是指向父类。

- 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。

```javascript
    class A {}
    class B extends A { }
    //相当于两条继承链的继承
    class A {}
    class B {}
    Object.setPrototypeOf(B,A); //静态属性的继承,构造函数的继承
    Object.setPrototypeOf(B.prototype,A.prototype); //实例继承，prototype的继承

    //两种方式都实现类的继承
    B._proto_ = A;
    B.prototype._proto_ = A.prototype; 
```

extends关键字后面可以跟多种类型的值。

只要是一个有prototype属性的函数，就能被继承。由于函数都有prototype属性（除了Function.prototype函数），因此可以是任意函数。


```javascript
    //子类继承Object类
    class A extends Object {
    }

    A.__proto__ === Object // true
    A.prototype.__proto__ === Object.prototype // true
    //A其实就是构造函数Object的复制，A的实例就是Object的实例。

    //不存在任何继承。
        class A {
    }

    A.__proto__ === Function.prototype // true
    A.prototype.__proto__ === Object.prototype // true
    //A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。
    //A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。
```

# 原生构造函数的继承

Boolean()   Number()    String()    Array()     Date()      
Function()  RegExp()    Error()     Object()

ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。

ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。

```javascript
    //es5
    function MyArray(...arg) {
        Array(...arg);
    }
    MyArray.prototype = Object.create(Array.prototype,{
        constructor: {
            value: MyArray,
            writable: true,
            configurable: true,
            enumerable: true
        }
    });
    //属性无法继承

    //es6
    class MyArray extends Array {
        constructor(...args) {
            super(...args);
        }
    }

    var arr = new MyArray();
    arr[0] = 12;
    arr[1] = 1;
    arr.length // 1
```

继承Object的子类，有一个行为差异。

```javascript
    class NewObj extends Object{
        constructor(){
            super(...arguments);
        }
    }
    var o = new NewObj({attr: true});
    o.attr === true  // false
    //ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6 规定Object构造函数会忽略参数。
```

# Mixin 模式的实现

定义：**多个对象合成一个新的对象，新对象具有各个组成成员的接口。**



