# 属性的简洁表示法

属性名就是变量名, 属性值就是变量值。

```javascript
    //属性
    //es5
    const foo = 'nba';
    const baz = {foo: foo};

    function f(x,y) {
        return {x: x, y: y};
    }
    //es6
    const baz = {foo};

    function f(x,y) {
        return {x, y};
    }


    //方法
    //es5
    const obj = {
        method: function () {}
    }

    //es6
    const obj = {
        method() {}
    }

    //例子
    let birth = '2000/01/01';

    const Person = {

    name: '张三',

    //等同于birth: birth
    birth,

    // 等同于hello: function ()...
    hello() { console.log('我的名字是', this.name); }

    };
```

# 属性名表达式

es5 （标识符）定义属性；

es6 允许（表达式）作为对象的属性名，即把表达式放在方括号内。

```javascript
    let lastWord = 'last word';

    const a = {
        'first word': 'hello',
        [lastWord]: 'world'
    };

    a['first word'] // "hello"
    a[lastWord] // "world"
    a['last word'] // "world"
```

属性名表达式与简洁表示法，不能同时使用，会报错。

属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。

```javascript
    const bar = 'abc';
    const baz = { [foo] };      //报错
```

# 方法的 name 属性

对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。

bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。

对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。

```javascript
    //getter函数和setter函数的name
    const obj = {
        get foo() {},
        set foo(value) {} 
    };

    obj.foo.name // TypeError: Cannot read property 'name' of undefined

    const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

    descriptor.set.name;    //'set foo'
    descriptor.get.name;    //'get foo'

    //bind 和 new
    function something() {}
    something.bind().name   //'bound something'
    
    (new Function()).name   //'anonymous'

    //symbol
    const key1 = Symbol('description');
    const key2 = Symbol();

    let obj = {
        [key1]() {},
        [key2]() {}
    };
    obj[key1].name  //'[description]'
    obj[key2].name  //''
```

# 属性的可枚举性和遍历

1. 可枚举性

描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。

四个操作会忽略enumerable为false的属性。

- for...in循环：只遍历对象自身的和继承的可枚举的属性。

- Object.keys()：返回对象自身的所有可枚举的属性的键名。

- JSON.stringify()：只串行化对象自身的可枚举的属性。

- Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。

引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。

```javascript
    //对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。
    Object.getOwnPropertyDescriptor(Object.prototype,'toString').enumerable     //false
    Object.getOwnPropertyDescriptor([],'length').enumerable     //false
```
尽量不要用for...in循环，而用Object.keys()代替。

2. 属性的遍历

（1）for...in   

for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

（2）Object.keys(obj)

Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

（3）Object.getOwnPropertyNames(obj)

Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

（4）Object.getOwnPropertySymbols(obj)

Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。

（5）Reflect.ownKeys(obj)

Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

# super关键字

super，指向当前对象的原型对象。

super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。

JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。

```javascript
    //super用在属性里面,报错
    const obj = {
        foo: super.foo
    }
    //super用在一个函数里面，然后赋值给foo属性，报错
    const obj = {
        foo: () => super.foo
    }

    const proto = {
        x: 'hello',
        foo() {
            console.log(this.x);
        }
    }
    const obj = {
        x: 'world',
        foo() {
            super.foo();
        }
    }
    Object.setPrototypeOf(obj,proto);
    obj.foo();  //'hello'
```

# 对象的扩展运算符

1. 结构赋值

解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。

解构赋值必须是最后一个参数，否则会报错。

解构赋值的拷贝是浅拷贝。

扩展运算符的解构赋值，不能复制继承自原型对象的属性。

```javascript
    const o = Object.create({ x: 1, y: 2 });
    o.z = 3;

    let { x, ...newObj } = o;   //x = 1, newObj 不继承原型
    x;  //1
    newObj.x;   //undefined
    newObj.y;   //undefined
    newObj.z;   //3

    //解构赋值中扩展运算符后面必须是一个变量名
    let {x, ...{y, z}} = o;
```

2. 扩展运算符

```javascript
    //对象
    let z = {a: 3, b: 4};
    let n = {...z};
    n;  //{a: 3, b: 4}

    //数组
    {...['a','b','c']};     //{'0': "a",1: "b", "2": "c"}

    //空对象
    {...{}, a: 1};      // { a: 1 }

    //不是对象(自动将其转为对象)
    {...1} //  // 等同于 {...Object(1)}   {}
    {...true} // 等同于 {...Object(true)} {}
    {...undefined} // 等同于 {...Object(undefined)} {}
    {...null} // 等同于 {...Object(null)} {}

    //字符串
    {...'hello'}    // {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"} v

    //合并对象
    let ab = { ...a, ...b };
    // 等同于
    let ab = Object.assign({}, a, b);

    //扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。
    // 并不会抛出错误，因为 x 属性只是被定义，但没执行
    let aWithXGetter = {
        ...a,
        get x() {
            throw new Error('not throw yet');
        }
    };

    // 会抛出错误，因为 x 属性被执行了
    let runtimeError = {
        ...a,
        ...{
            get x() {
            throw new Error('throw now');
            }
        }
    };
```

# Object.is()

相等运算符（==）:  自动转换数据类型.

严格相等运算符（===）:  NaN不等于自身; +0等于-0.

Object.is:  “Same-value equality”（同值相等）算法 .(一是+0不等于-0，二是NaN等于自身)

```javascript
    //es5实现
    Object.defineProperty(Object, 'is', {
        value: function(x, y) {
            if (x === y) {
                // 针对+0 不等于 -0的情况
                return x !== 0 || 1 / x === 1 / y;
             }
            // 针对NaN的情况
            return x !== x && y !== y;
        },
        configurable: true,
        enumerable: false,  
        writable: true
    });
```

# Object.assign()

1. 基本用法

用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。

目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。

```javascript
    //只有一个参数，Object.assign会直接返回该参数。
    const obj = {a: 1};
    Object.assign(obj) === obj; //true

    //参数不是对象，则会先转成对象，然后返回。
    Object.assign(2)  //Number{2}

    //undefined和null无法转成对象，所以如果它们作为参数，就会报错。
    Object.assign(undefined);
    Object.assign(null);

    //非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。
    let obj = {a: 1};
    Object.assign(obj, undefined) === obj // true
    Object.assign(obj, null) === obj // true

    //除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。
    const v1 = 'abc';
    const v2 = true;
    const v3 = 10;

    const obj = Object.assign({}, v1, v2, v3);
    console.log(obj); // { "0": "a", "1": "b", "2": "c" }
```
布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。

2. 注意点

- 浅拷贝

- 同名属性的替换

- 数组的处理

```javascript
    Object.assign([1, 2, 3], [4, 5]);
    // [4, 5, 3]
```
- 取值函数的处理

```javascript
    //Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。
    const target = {
        get foo() {
            return 1;
        }
    }
    Object.assign({},target);   //{foo: 1}
```

3. 常见用途

```javascript
    //为对象添加属性
    class Point {
        constructor() {
            Object.assign(this,{x,y});
        }
    }

    //为对象添加方法(使用了对象属性的简洁表示法)
    Object.assign(SomeClass.prototype, {
        someMethod(arg1, arg2) {
            ···
        },
        anotherMethod() {
            ···
        }
    });

    //克隆对象
    function clone(origin) {
        var originProto = Object.getPrototypeOf(origin);
        return Object.assign(Object.create(originProto),origin);
    }

    //合并对象
    const merge =
        (target, ...sources) => Object.assign(target, ...sources);

    const merge =
        (...sources) => Object.assign({}, ...sources);

    //为属性指定默认值
    const DEFAULTS = {
        logLevel: 0,
        outputFormat: 'html'
    };

    function processContent(options) {
        options = Object.assign({}, DEFAULTS, options);
        console.log(options);
        // ...
    }
    //DEFAULTS对象是默认值，options对象是用户提供的参数.如果两者有同名属性，则options的属性值会覆盖DEFAULTS的属性值。
```
# Object.getOwnPropertyDescriptors()

返回指定对象所有自身属性（非继承属性）的描述对象。

Object.getOwnPropertyDescriptors()方法配合Object.defineProperties()方法，就可以实现正确拷贝。

```javascript
    const source = {
        set foo(value) {
            console.log(value);
        }
    };

    const target2 = {};
    Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));

    //合并两对象
    const shallowMerge = (target, source) => Object.defineProperties(
        target,
        Object.getOwnPropertyDescriptors(source)
    );
```

# __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf() 

如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。

# Object.fromEntries()

Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。





