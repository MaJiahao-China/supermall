# 浏览器端实现模块化的缺点

在node端实现模块化，node运行的是本地的文件，在本地读取文件效率比浏览器端远程传输文件高得多；

浏览器端，模块划分得越细，请求的文件数量越多，效率越低；

# 根本原因

区分开发时态(devtime)和运行时态(runtime)

1. devtime:

- 模块划分越细越好

- 支持多种模块化标准

- 支持npm或其他包管理器下载的模块

- 能够解决其他工程化的问题

2. runtime：

- 文件越少越好

- 文件体积越小越好

- 代码内容越乱越好

- 所有浏览器都兼容

- 解决其他运行时的问题如执行效率问题

# 构建工具

将开发时态编写的代码转换为运行时态需要的东西。

webpack，grunt，gulp。。。

# 模块化兼容性

es6 -> commonJs

```js
export default class A {}

const A = require('./A').default
```

commonJs -> es6

```js
module.exports = {
  a: 1,
  b: 2,
  c: 3
}

import * as obj from ''
// same as
import obj from ''
```