# 例：index.js 文件对 a.js 文件有依赖，通过webpack打包后的文件(手写原理)

## 文件间的模块语法是让 webpack 来读取打包的，并不需要浏览器或服务器来执行
```js
(function(modules) {
  //缓存模块的导出结果
  const moduleExports = {};
  //require函数运行一个模块，得到导出结果
  function _webpack_require(moduleId) {
    if (moduleExports[moduleId]) {
      // 检查是否有缓存，有的话直接返回结果
      return moduleExports[moduleId];
    }
    const func = modules[moduleId];
    const module = {
      exports: {}
    }
    func(module, module.exports, _webpack_require);
    const result = module.exports;
    moduleExports[moduleId] = result;
    return result;
  }

  _webpack_require("./src/index.js");//执行入口模块
})({
  // 将每个模块放入函数，路径作为属性名，这样属性名就是唯一的，函数作为属性值
  //该对象保存了所有的模块，以及模块对应的代码
  "./src/a.js": function (module, exports) {
    //a.js的代码
    module.exports = function() {
      console.log('I am a.js');
    }
  },
  "./src/index.js": function (module, exports, _webpack_require) {
    //index.js
    const a =  _webpack_require('./src/a.js'); //路径修改为属性名，这样就可以拿到另一个模块的代码
    a();
    console.log('hello webpack!');   
  }
})
```

## webpack 打包文件分析( commonJs 为例)

1. 创建一个**模块对象**, 以 **文件路径(路径一定是唯一的)** 为属性，匿名函数 (函数内是文件内容即运行的代码) 为值

2. 匿名函数传入三个值 `module` `exports` `require`

3. 将这个**模块对象**作为参数传入一个立即执行函数

4. 创建`require`函数依次执行模块内的代码 (从入口文件开始),返回运行结构

5. 缓存已运行过的模块的导出结果

将模块代码放入```eval("")```运行方便调试

