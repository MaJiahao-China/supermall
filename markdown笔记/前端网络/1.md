# 互联网起源

1989年 欧洲粒子物理研究所———— 协议（格式）
WWW（world wide web）

# 局域网

1. 冯诺依曼式计算机--计算机之父

运算器：CPU, GPU(显卡) 前者多整数运算，后者浮点数运算

存储器：内存(断电数据清空, 读写速度快)  硬盘/辅存(数据可以持久化,读写速度,相对较慢)

控制器：主板上的一些器件

输入设备：键盘，鼠标， 麦克风， 网口

输出设备：显示器，耳机，网口

2. 多个计算机和路由器可以组成局域网

# IP地址与公网

## IP地址

1. IP地址的格式：

IP地址分为四个段：xxx.xxx.xxx.xxx,每段0~255,由八个0/1组成

2. IP地址的分类： 一个IP地址分为两个部分：网络ID，主机ID

A类：0.0.0.0 ~ 127.255.255.255 (一个网络能有1600+万台)

B类：128.0.0.0 ~ 191.255.255.255

C类：192.0.0.0 ~ 223.255.255.255

**A,B,C类IP地址本质上是一样的，区别在于局域网内能有的机器数量**

D类：（多播地址）

E类：

## 例：

1. 在路由器链接多个计算机时，计算机上的是私有IP地址，路由器上的是通信商提供的公有IP地址。

2. 如果要搭建一个服务器让别人链接到，就必须有一个公网IP。


# 域名与DNS解析

1. 域名能直接访问一台机器吗？

- 不能，用域名和IP形成对应关系

2. 计算机不认识域名对应的IP，怎么办？

- 向上访问路由器，若路由器认识这个域名，返回一个IP，计算机访问IP。

- 层层向上，若到了城市级别的路由器，就是DNS服务器(domain name system 域名系统协议)。

- 若DNS服务器不认识域名，继续向上级DNS服务器查找。

3. 浏览器的地址栏中输入一个url并回车，网络发生什么？

- 浏览器查找域名的IP地址，这一步包括DNS具体的查找过程：浏览器缓存->系统localhost缓存->路由器缓存->DNS->gDNS

- 浏览器向web服务器发送一个HTTP请求
 
- 服务器的永久重定向响应(http://xxx.com -> http://www.xxx.com)

- 浏览器跟踪重定向地址

- 服务器处理请求

- 服务器返回一个HTTP响应

- 浏览器显示HTML

- 浏览器发送请求获取资源(图片，音频，视频，css，js)

- 浏览器发送异步请求

# 五层网络模型

## 软件层面：

- 应用层(浏览器/服务器)：如HTTP协议 DNS协议(定义在软件层)

- 运输层：如TCP协议 UDP协议 (传输控制协议Transmission Control Protocol，用户数据报协议User Datagram Protocol，前者更安全)

(1)TCP协议面向有链接，能正确处理丢包，传输顺序错乱的问题，但是为了建立与断开链接，需要至少7次的发包收包，资源浪费；

(2)UDP面向无连接，不管对方有没有收到，如果要得到通知，需要通过应用层；

(3)**TCP三次握手和四次挥手？**

    三次握手：

    - 客户端-发送带有SYN标志的数据包-一次握手-服务器

    - 服务端-发送带有SYN/ACK标志的数据包-二次握手-客户端

    - 客户端-发送带有ACK标志的数据包-三次握手-服务端

    四次挥手：

    - 客户端-发送一个FIN，用来关闭客户端到服务器的数据传送

    - 服务器-收到这个FIN，发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号

    - 服务器-关闭与客户端的连接，发送一个FIN给客户端

    - 客户端-发回ACK报文确认，并将序号设置为收到序号为1

- 网络层：如IP协议(Internet Protocol，网络互联协议两个字段，存储双方的IP地址)

## 硬件层面：

- 链路层：代表驱动

- 物理层：将(1)二进制的0和1，(2)电压高低，(3)光的闪灭，(4)电波的强弱信号转换

1. HTTP协议分为两个部分：(1)请求(request)  (2)响应(response)

2. 浏览器要访问一个接口/网站时，要层层包装，HTTP协议再交给操作系统包装，如发送'hello world'

物理协议 IP协议(双方的IP，双方的接口)    TCP协议    HTTP协议--(请求头) 'hello world'

传输协议时层层加密，发送后层层向上解密

3. **http传输流**

发送端在层与层之间传输数据时，没经过一层都会被加上首部信息，接收端没经过一层都会删除一条首部

# HTTP协议

1. 请求 Request 

两部分: 请求头( **请求方式(GET/POST/HEAD/PUT/DELETE) + 路径 + 协议版本**) + 数据体

如：GET/path?a=1&&b=2 HTTP1.1

Host: www.baidu.com

Connection:keep-alive

User-Agent:...

2. 响应 Response

两部分: 响应头(**协议版本 + 状态码 + message**) + 数据体


# GET 和 POST 的区别

1. 基于什么前提。如果什么前提都没有，不使用任何规范，只考虑语法和理论上的HTTP协议？

get和post没有区别，只是名字不同而已

2. 如果是基于RFC(Request For Comments，一系列以编号排定的文件)规范？

- 理论上(specification):都具有相同语法，但是有不同的语义，get用来获取数据，post用来发送数据，其他没有区别。

- 实现上(implementation): 各种浏览器是这个规范的实现者。不同可以表现在：

(1)显示：get在url中显示,post不显示

(2)长度：get请求对长度有限制,post长度无限制

(2)安全：get安全性较差(两者都较差),因为发送的数据是url的一部分

(3)缓存：get历史参数会被保留在浏览器里,post不会保留在浏览器里

(4)刷新;get请求后,后退和刷新按钮无影响,post数据会被重新提交

(5)get编码类型: application/x-www-form-url, post的编码类型：encodeapplication/x-www-form-urlencoded/  multipart/form-urlencoded

(6)get只允许ASCII。post没有编码限制,允许发二进制码

(7)get请求的数据可以收藏为书签，post不能收藏为书签



# Cookie Session

- 如果我们用js的变量来存数据,那么网页关闭的时候，数据就消失了。

- HTTP能否保持登录状态？ 按照正常的HTTP协议做不到,http协议又称上下文无关协议。

1. cookie：前端页面上,可以持久化存储数据的内存空间。一旦登录成功，就记载在哪里。

- cookie存在浏览器里,不同页面可以访问相同的cookie,可以长期存储。

- cookie是有限制的，cookie即使保存在浏览器里,也是放在不同的域名下。

- 例子：登录百度账号 -> 百度域名下设置一个cookie -> 再次发送请求,带上cookie -> 解密cookie的ID,获取ID -> 确认等录，保留用户信息

- 缺点：安全性，cookie可能被他人复制

2. session：

- 若保持连接，登录信息保存在服务器上；相对安全

- 缺点：用户量大时，服务端很耗资源；后端服务器很多，用户的登录信息，一般只能存在一台服务器上。用户的登录操作，在哪台机器上执行，就一般存在哪台机器上。

- 解决方法：通过反向代理。轮询，IP哈希(相同IP打在同一服务器上)

# 页面的打开方式

1. B/S结构   C/S结构   Client-app(Browser-网页)/Server -- 前者展示内容，后者提供内容

2. 页面的本质是什么？ 带有**HTML格式的**字符串

问：浏览器向服务器请求一个页面的本质的什么？

- 服务器收到请求，服务器想把这个页面（带有**HTML格式的**字符串）返回给浏览器。

- 页面的字符串存在HTML文件里

- 服务端读取文件

- 将读取的内容返回给浏览器（返回的是一个字符串，来源可能是文件，缓存，数据库）

3. 服务器和服务容器

- 服务器：严格的说，是一台计算机，只提供服务。

- 服务容器：是一个程序。可以监听一个接口。读取文件并返回。（我们通常说的服务器就是这个服务容器，我们要通过服务器的方式，访问自己的页面，就要安装一个服务容器）

# ajax 

## 发送网络请求方式

1. 浏览器直接输入网址

2. location.href='url',可以发送网络请求，但是页面会发生跳转。

3. 带有src/href/action属性的标签。请求是可以发出的，服务端也会处理并返回。但是如何处理是要看浏览器

4. ajax请求：可以用代码控制，页面不会跳转，服务端返回的结果可以用js继续处理。

## 跨域请求

1. 浏览器处理的资源：js，css，图片，src/href等资源

2. 需要js代码处理的资源：后端接口的数据；其他域的缓存，其他域的cookie

3. 怎样算跨域？

- 页面本身有：http协议 域名 端口；发送请求时，三者有一个不一样就算跨域。

- 跨域发生在什么时候？即使跨域，请求照样发出，服务端照样接收，处理，返回数据；浏览器照样接收数据，**直到发现当前的域和请求的域不一样，才判定为跨域。这样需要跨域请求的资源就不会传递给代码**。

4. 解决跨域问题？

- 后端配合跨域。(1)jsonp(正常情况下返回的是json格式) (2)设置Access-Control-Origin属性支持跨域。

- 后端不配合跨域。(3)iframe(只能显示，不能控制)(4)后端代理(自己的后端)

## 原生js发送ajax

1. XMLHttpRequest对象

- 属性：

readState 状态         0--创建对象后     1--建立连接后      2,3--发送过程中      4--发送成功后  

status    http状态码   

    2** --成功

    - 200 OK(从客户端发来的请求在服务器端被正确处理)
    
    - 204 No content(请求成功但响应报文不含实体的主体部分)    

    - 206 Partial Content(进行范围请求)

    3** --重定向

    - 301 moved permanently(永久性重定向，表示资源已被分配给新的url)  

    - 302 found (临时性重定向，资源临时被分配给新的url)

    - 303 see other (资源存在着另一个url，应使用get方法定向获取)

    - 304 not modified

    - 307 temporary redirect

    4**--客户端错误  

    - 400 bad request

    - 401 unauthorized

    - 403 forbidden (对请求资源的访问被服务器拒绝)

    - 404 not found (服务器上没有找到请求的资源)

    5**--服务端错误  

    - 500 internal sever error

    - 503 service unavailable (服务器暂时超负载或停机维护，无法处理请求)



- 方法:

open()  建立连接 参数：请求方式，域名，是否异步

send()  发送请求
```javascript
function ajax(config) {
    const {url, type, data, success, flag} = config;
    let xhr = null;
    if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
    }else {
        xhr = new ActiveXObject('Microsoft.XMLHttp');//兼容ie6.0
    }

    if (type == 'GET') {
        xhr.open(type, url + '?' + data, flag);
        xhr.send();
    } else if(type == 'POST') {
        xhr.open(type, url , flag);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencode');
        xhr.send(data);
    }
    //readyState
    // 0 -- 当前代理已创建，未调用open方法
    // 0 -- 调用open创建连接
    // 2 -- send方法调用
    // 3 -- 代表正在接收响应信息
    // 4 -- 代表响应数据发送完成 
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                success(JSON.parse(xhr.responseText));
            } else {
                throw new Error('error!');
            }
        }
    }
}  

ajax({
    url: 'https://developer.duyiedu.com/edu/testAjaxCrossOrigin',
    type: 'GET',
    flag: true,
    success: val => console.log(val),
})
```

## jsonp

1. 返回的结构不是json，是'callback名 + (json)'

2. jsonp跨域，只能使用get方法，如果设置的是post方法，jquery会自动转为get方法。

3. jquery会判断是否同源，同源情况下不会改变，不是同源情况下会把post方法转为get方法。

4. 如果要从一个接口获取数据，但是不同源(跨域)，且接口支持jsonp；script标签有src属性可以发送网络请求，可以引用其他域的资源，但会把返回内容作为js执行

5. jsonp原理：

前端部分：

- 判断请求与当前页面的域，是否同源，若同源则发送正常的ajax；

- 生成随机callback名字，创建相应的方法；

- 不同源，生成script标签；

- 设置script的src为请求的接口

- 将callback作为参数拼接在后面

后端部分：

- 后端接收到请求后，开始准备要返回的值

- 后端拼接数据，将要返回的数据用callback的值和括号包裹起来

- 返回内容；

- 浏览器接收内容，当做js代码执行

```javascript
    $.extend({
        myAjax(option) {
            const {url, type, dataType, success} = option;
            //判断是否同源
            //1.获取目标url的域
            var targetProtocol = '';
            var targetHost = '';
            if (url.includes('https://') || url.includes('http://')) {  //同源，相对路径
                var targetUrl = new URL(url);
                targetProtocol = targetUrl.protocol;
                targetHost = targetUrl.host;
            } else {
                targetProtocol = location.protocol;
                targetHost = location.host;
            }

            if (dataType == 'jsonp') {
                //1.是否同源
                if (targetProtocol == location.protocol && targetHost == location.host) {
                    //同源发送正常的ajax请求
                } else {
                    //2. 随机生成一个callback名
                    var callback = 'cb' + Math.floor(Math.random() * 10000);
                    //添加方法
                    window[callback] = success;
                    //3. 创建script标签
                    var script  = document.createElement('script');
                    //4. 设置script的src为请求的接口
                    if (url.includes('?')) {
                        script.src = url + '&callback=' + callback;
                    } else {
                        script.src = url + '?callback=' + callback;
                    }
                    script.id = callback;
                    document.head.appendChild(script);
                    //后端会返回数据并以数据为参数自动执行callback函数
                }
            }
        }
    });


    $.myAjax({
        url: "http://developer.duyiedu.com/edu/testJsonp",
        type: "get",
        dataType: "jsonp",
        success: function (data) {
            console.log(data);
        }
    });
```










