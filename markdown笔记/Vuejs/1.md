# 数据渲染是异步的

1. 属性： 

$el        绑定的dom对象

2. 方法： 

$nextTick  dom更新后执行的方法，参数可以是回调函数；

$mount     传入dom对象，和vue对象中的参数el作用相同

## 简单的原理

数据更改同步，视图更新异步

```html
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <div id="app">
        {{ a }}
    </div>
```

```javascript
    const vm = new Vue({
        data: {
            a: 10,
        }
    });
    vm.$mount('#app');
    vm.a = 20;
    console.log(vm.a);
    console.log(vm.$el.innerHTML);

    vm.$nextTick(() => {
        console.log(vm.$el.innerHTML);
    });
```

```html
    <div id="app">
       <ul>
           <li v-for="(lanObj) in languages" :key='lanObj.id'>{{ lanObj.lan }}</li>
       </ul>
       <button @click='handleClick'>顺序变一下</button>
    </div>
    
    <script>
        const vm = new Vue({
            el: "#app",
            data: {
                languages: [
                    {id: 1, lan: 'css'}, 
                    {id: 2, lan: 'javascript'}, 
                    {id: 3, lan: 'python'}, 
                    {id: 4, lan: 'c++'}],
            },
            methods: {
                handleClick() {
                    this.languages.reverse();
                }
            }
        });
       
```


# 计算属性， 侦听器

## 用法区别

|methods  |每次重绘都会调用里面的方法,性能较低  | 用于逻辑，触发事件|
| :---: | :---: |:---:|
|watch侦听器|侦听data同名数据，数据更改较多时造成代码冗余|  数据改变时触发的方法|
|computed计算属性|必须有一个返回值，只更改相应的位置| 得到一个新的数据|


## 属性调用顺序：

data => methods => computed

# 组件

## 全局组件和局部组件

```javascript
    //全局组件
    Vue.component('helloWorld', {
        //数据，以函数形式使每个组件数据分离
        data() {
            return {
                msg: 'hello world'
            }
        },
        //组件模板
        template:`<div><button @click='handleClick'>点击</button><span>{{ msg }}</span></div>`,
        methods: {
            handleClick() {
                this.msg = (this.msg === 'hello world')? 'hello Vue':'hello world';
            }
        }
    });

    const vm = new Vue({
        el: '#app',
        //局部组件
        components: {
            hello: {
                //...(与全局相同)
            }
        }
    });
```

## 组件数据传输和校验


改变父子组件数据的最佳方法

1. 为什么不能通过改变子组件数据改变父组件？

父组件传递数据是传递其引用，若有多个子组件会造成其他子组件的改变

解决： 将props的数据放入data作为自己的数据

2. 子组件方法触发后，继续执行emit里的方法，把子组件改变后的数再传回父组件

3. 改进方法，不改变子组件的data数据，而是采用props里的数据，触发方法传递改变的量，在传给父组件

```html
    <div id="app">
        <!-- <my-content :title='title' :time='time'></my-content>    -->
        <my-content v-bind='childrenInfo' v-on:add='handleAdd'></my-content>
        父组件数字：{{ childrenInfo.number }}
    </div>
```
```javascript
    const vm = new Vue({
        el: '#app',
        data: {
            // title: "Vue",
            // time: "2019-11-30"
            //当数据在一个对象里时
            childrenInfo: {
                title: "Vue",
                time: "2019-11-30",
                number: 0
            },
        },
        methods: {
            handleAdd(num) {
                this.childrenInfo.number += num;
            }
        },
        //局部组件
        components: {
            myContent: {
                //父组件向子组件通信:将属性名以字符串形式的数组传入
                // props: ['title', 'time'],
                //以对象的对象形式传入
                props: {
                    title: {
                        //类型检验，只报错
                        type: String,
                        //默认值，可以不写 :title='title'
                        default: "Javascript",
                        //必须传值(必须写 :title='title') 
                        required: true
                    },
                    time: {
                        type: String,
                        //校验函数,参数就是这个值
                        validator(value) {
                            const reg = /\d{4}-\d{1,2}-\d{1,2}/;
                            return reg.test(value);
                        }
                    },
                    number: {
                        type: Number
                    }
                },
                // data() {
                //     // return {
                //     //     myNumber: this.number
                //     // }
                // },
                template:`
                    <div>
                        <h2>{{ title }}</h2>
                        <p>{{ time }}</p>  
                        <p>子组件数字：{{ number }}</p>   
                        <button @click='handleClick'>点击增加数值</button>       
                    </div>
                `,
                methods: {
                    handleClick() {
                        // this.myNumber += 10;
                        //子组件方法触发后，继续执行emit里的方法，把子组件改变后的数再传回父组件
                        // this.$emit("add", this.myNumber);
                        console.log('点击了！');
                        this.$emit("add", 10);
                    }
                } 
            }
        }
    });

```

