# 计数器中的MVVM

1. Vue中的MVVM 

- DOM -- view

- Model -- obj

- ViewModel -- Vue实例对象

2. 工作原理

- ViewModel通过Data Binding让obj中的数据实时在DOM中显示

- ViewModel通过DOM Listener来监听DOM事件，且通过methods中的操作，改变obj的数据

# 计算属性

1. 计算属性具有缓存效果。

- methods和computed的对比：当多次需要一个拼接的值时，计算属性不会多次调用，vue内部会缓存，只有在拼接值修改时才会调用

2. 计算属性的setter和getter

- 计算属性本质上是一个属性描述对象；

- 计算属性不设置setter方法，原则上不让修改计算属性值。

```javascript
const app = new Vue({
    el: '#app',
    data: {
        firstName: 'Kobe',
        lastName: 'Bryant'
    },
    computed: {
        fullName: {
            get() {
                return this.firstName + ' ' + this.lastName;
            },
            set(newName) {
                const names = newName.split(' ');
                this.firstName = names[0];
                this.lastName = names[1];
            }
        }
    }
})
```


# 组件的key属性

1. 与vue的虚拟dom的diff算法有关；

2. 用key给每个节点做一个标识，diff算法就可以正确的识别此节点，找到正确的位置插入新的节点；

3. key的作用就是为了**高效的更新虚拟dom**。


# 渲染的条件：数据响应式的实现 -- 变异数组和Object.defineProperty

- 初始值更改一定渲染；

- 数组：(1)索引的方式更改数组(2)更改数组长度 不发生渲染了;

(2)数组变异方法(push,pop,shift,unshift,splice,sort,reverse)可以发生渲染

- 对象：更改已有属性可以渲染; 增加或减少属性不发生渲染；

- 方法$set(obj, "attr", value)通用可以渲染

```javascript
const data = {
    obj: {a: 1, b: 'cba'},
    arr: [2, 'nba'],
    num: 1,
}

function render() {
    console.log('render OK!');
}

function defineReactive(data, key, value) {
    //如果value是对象，劫持value所有属性值
    if (typeof value === 'object') {
        observe(value);
    }
    //如果value是原始值，直接进行数据(劫持)代理
    Object.defineProperty(data, key, {
        get() {
            return value;
        },
        set (newValue) {
            if (newValue === value) {
                return;
            }else {
                value = newValue;
                render();
            }
        }
    })
}

//数组变异方法的实现
function getNewArrayProto() {
    const arrayProto = Array.prototype;
    const newArrayProto = Object.create(arrayProto);
    ['push','pop','shift','unshift','splice','sort','reverse'].forEach(method => {
        newArrayProto[method] = function (...arg) {
            arrayProto[method].apply(this, arg);
            render();
        }
    })
    return newArrayProto;
}

//劫持所有数据
function observe(data) {
    if (Array.isArray(data)) {
        Object.setPrototypeOf(data, getNewArrayProto());
        return;
    }
    if (typeof data === 'object') {
        for (let key in data) {
            proxy(data, key, data[key]);
        }
    }
}

//$set
function $set(data, key, value) {
    if (Array.isArray(data)) {
        data.splice(key, 1, value);
        return value;
    }
    if (typeof data === 'object') {
        //若数据是添加上去的那么劫持好数据，以便下次修改可以渲染
        proxy(data, key, value);
        //设置好了就要渲染一次
        render();
        return value;
    }
}
observe(data);
```

