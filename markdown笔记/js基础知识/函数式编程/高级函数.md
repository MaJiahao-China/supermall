## call, apply, bind的模拟实现 

```javascript
// 在context下创建属性指向this，再调用this后销毁
// call和apply思想一样，只是参数不同
Function.prototype.newCall = function (context, ...param) {
    if (typeof context == 'function' || typeof context == 'object') {
        context = context || window;
    } else {
        context = Object.create(null);
    }
    var fn = Symbol();
    context[fn] = this;
    var res = context[fn](...param);
    delete context[fn];
    return res;
}


/*
1. 函数A调用方法bind时，需要传入的参数obj，x，y，z ...
2. 返回新的函数B
3. 函数B执行的时候，具体的功能还是A的，只是把this指向从window变成了obj
4. 函数B执行的时候，传递的参数会拼接到xyz后面，一起传入A
5. new B() 构造函数依然是A，obj不起作用；

*/
Function.prototype.newBind = function (target = window, ...arg1) {
    var self = this;
    f.prototype = Object.create(self.prototype);
    return function f(...arg2) {
        return self.call(f instanceof self ? this : target, ...arg1, ...arg2);
    };
}

```


## 纯函数

纯函数：不依赖，修改其作用域之外的变量的函数；

## 函数柯里化

柯里化：将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。
    
```javascript
    function curring(fn) {
        const len = fn.length;
        return function curr(...arg1) {
            if(arg1.length >= len) {
                return fn(...arg1);
            }else {
                return (...arg2) => curr(...arg1,...arg2); 
            }
        }
    }


    //反柯里化
    Function.prototype.unCurrying = function() {
        return () => {
            return Function.prototype.call.apply(this, arguments);
        }
    };  
```

## 函数节流(throttle)

预定一个函数只有在**大于等于执行周期时才执行**，周期内调用不执行。
如：窗口调整(resize)，页面滚动(scroll)，抢购疯狂点击(mousedown)

```javascript
    //函数节流
	// 立即执行
    const throttle = function (handler,waitTime) {
        let lastTime = 0;
        return function(...arg) {
            const nowTime = new Date().getTime();
            if(nowTime - lastTime > waitTime) {
                handler.call(this, ...arg);
                lastTime = nowTime;
            }
        }
    }
	// 周期后执行
    const throttle = function (handler, waitTime) {
        let timer = null;
        return function (...arg) {
            if (!timer) {
                timer = setTimeout(() => {
                    handler.call(this, ...arg);
                    timer = null;
                }, waitTime);
            }
        }
    }
```

## 函数防抖(debounce)

函数需要频繁触发情况时，**只有足够空闲的时间，才执行一次**。
实时搜索，拖拽

```javascript
   //函数防抖
const debounce = function (handler, delay) {
  let timer = null;
  const setTimer = (args) => {
    timer = setTimeout(() => {
      handler.apply(this, args);
      timer = null;
    }, delay * 1000);
  }
  return function (...args) {
    if (timer) {
      clearTimeout(timer);
      setTimer(args);
    } else {
      setTimer(args);
    }
  } 
}
```

## 安全的类型检验

typeOf -> instance of -> Object.prototype.toString()

## 作用域安全的构造函数

1. instance of 类型判断  

2. 继承时通过原型链矫正prototype

```javascript
function Person(name, age, job) {
    if (this instanceof Person) {
        this.name = name;            
        this.age = age;
        this.job = job;
    } else {
        return new Person(name, age, job);
    }    
}    

function Student(grade, name, age) {
    Person.call(this, name, age, 'student');
    this.grade = grade;
} 

Student.prototype = new Person();
```

## 惰性载入函数

1. 定义：让函数执行的分支只发生一次

2. 方法：

- 在函数被调用时在处理函数

**每个分支的代码块都包成一个次函数，让主函数等于次函数，执行并返回**，后续执行就不需要判断了

- 在声明函数时就指定适当的函数

用一个**立即执行函数**立即判断，返回指定函数

## 自定义事件

1. 事件是js与浏览器交互的主要途径，事件是一种叫做观察者的设计模式。

2. 观察者模式由两类对象组成：主体和观察者。涉及到DOM时，DOM是主体，事件处理代码是观察者。

3. 主体负责发布事件，观察者订阅这些事件来观察主体。主体不知道观察者的事情，可以独自运作；观察者知道主体并且能注册事件的回调函数。

```javascript
// 自定义事件对象 
function EventTarget() {
    this.handlers = {};
}
EventTarget.prototype.addHandler = function (type, handler) {
    if (!this.handlers[type]) {
        this.handlers[type] = [];
    }
    this.handlers[type].push(handler);
}
EventTarget.prototype.fire = function (event) {
    if (!event.target) {
        event.target = this;
    }
    const handlers = this.handlers[event.type];
    if (handlers instanceof Array) {
        handlers.forEach(handler => {
            handler(event);
        });
    }
}
EventTarget.prototype.removeHandler = function (type, handler) {
    const handlers = this.handlers[type];
    let index = 0;
    for (let i = 0; i < handlers.length; i++) {
        if (handlers[i] == handler) {
            index = i;
            break;
        }
    }
    handlers.splice(index, 1);
}


var target = new EventTarget();
function say (event) {
    console.log(event.person);
}

target.addHandler('call', say);
target.fire({type: 'call', person: 'botao'});
target.removeHandler('call', say);
```
