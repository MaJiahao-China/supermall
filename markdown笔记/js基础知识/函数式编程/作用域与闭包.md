# 作用域

> 收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施严格的规则，确定标识符的访问权限

1. js的词法作用域分为全局作用域与函数作用域，作用域表示一个代码区域，也可以表示一个运行的环境

2. 全局作用域声明的变量会作为全局的属性，函数作用域内声明的变量不会成为全局对象的变量。**所以函数作用域声明的变量不会导致全局对象的污染。**

4. 将函数成为一个表达式，既不提升越不会污染全局对象。将函数作为表达式的方法之一就是用小括号()包起来，将其立即执行，就是立即执行函数IIFE(immediately invoked function expression)



# 闭包

> 闭包(closure)：可以记住并访问定义时所在的词法作用域的函数，使函数在当前词法作用域之外执行。

1. 模拟块级作用域

```javascript
function print(count) {
    (function () {
        for (let i = 0; i < count; i++) {
            alert(i);
        }
    })();
}
```

2. 实现私有变量和公有方法( 特权方法 )


```javascript
//构造函数模式实现自定义类型的特权方法
function MyObject() {
    var privateNum = 0;
    function privateFunc() {
        return false;
    }

    this.publicMethod = function () {
        privateNum++;
        return privateFunc();
    }
}
//模块(增强)模式实现单例的特权方法
var singleton = function() {
    var privateNum = 0;
    function privateFunc() {
        return false;
    }

    var obj = new Type();   //增强模式给单例一个类型
    obj.publicNum = 10;
    obj.publicMethod = function() {
        privateNum++;
        return privateFunc();
    }
    return obj;
}
```

## 执行上下文

1. 执行上下文：一个函数运行前，创建的一块**内存空间**，空间里包含有该函数执行所需要的数据，为该函数执行提供支持。

2. 执行上下文栈：所有执行上下文组成的内存空间。

全局执行上下文：所有js代码执行，必须有环境。

js引擎总是执行栈顶的上下文。

3. 执行上下文的内容

-  this指向 

(1)直接调用函数，this指向全局对象
(2)通过对象调用或new一个函数，那么this指向调用的对象或新对象

- VO 变量对象

variable object：VO中记录了该环境中所声明的参数，变量和函数

global object：GO，全局执行上下文的VO

active object：AO，当前正在执行的上下文的AO
`
- 作用域链

4. VO的创建，预编译过程(js的执行：词法分析，预编译，解释执行)：

(1)找到形参与声明的变量作为AO的属性，设置值为undefined

(2)形参实参统一，arguments

(3)在函数体找函数声明，函数名作为属性，函数体作为值 

## 作用域链

1. VO中包含一个额外的属性，该属性指向创建该VO的函数本身

2. 每个函数在创建时，都会有一个隐藏属性```[[scope]]```，指向创建该函数时的AO

3. 当访问一个变量时，会先查找自身AO中是否存在，否则依次查找```[[scope]]```属性

4. 某些浏览器会优化作用域链，函数的```[[scope]]```中仅保留需要用到的数据。

- 作用域链本质上是一个指向变量对象的指针列表，只包含引用但不实际包含变量对象。

- 在函数执行完后，其执行环境的作用域链会被销毁，但是内部若返回了闭包那么它的活动对象(AO)就会被留在内存。

- 函数在搜索变量this，arguments时，只会搜索到其活动对象为止。






