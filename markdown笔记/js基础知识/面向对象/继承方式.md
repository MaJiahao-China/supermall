# 原型链继承

- 将父类的实例作为子类的原型

```javascript
Super.prototype = new Father();
```

- 缺点：要为子类添加属性方法必须new父类后执行，否则无法实现多继承

# 构造函数继承

- call改变this指向

```javascript
function Super () {
    Father.call(this);
}
```

- 优点：实现多继承；

- 缺点：不能继承原型

# 实例继承

- 为父类添加新特性，作为子类实例返回

```javascript
function Super() {
    var instance = new Father();
    return instance;
}
```

- 缺点：不能实现多继承

# 拷贝继承

- 将父类属性和方法copy一份到子类

```javascript
function Super() {
    var father = new Father();
    for (var p in father) {
        Super.prototype[p] = father[p];
    }
}
```

- 优缺点：支持多继承，效率低占用内存

# 组合继承/寄生组合继承

- 1.调用父类构造，继承父类属性并**保留传参的优点**；2.父类实例作为子类原型，**实现函数复用**

- 寄生组合创建一个没有实例方法的父类

```javascript
function Super() {
    Father.call(this);
}
Super.prototype =  Object.create(Father.prototype);
Super.prototype.constructor = Super;
```

# ES6继承

- 先创建父类的实例对象this。再用子类的构造函数修改this

```javascript
class Super extends Father {
    constructor(arg, position) {
        //这里调用this报错
        super(arg);
        //这里不报错
        this.position = position;
    }
}
```