# 浅拷贝

- 含义：只进行一层的拷贝。

- 实现方法

  ```js
  // 1. 解构赋值
  const cloned = {...obj};
  // 对象的混入
  const mixin = {...obj1, ...obj2};
  
  // 2. assign
  const cloned = Object.assign({}, obj)
  ```

  

# 深拷贝

- 复制一个数据相同，所有的引用不同的对象

- 深拷贝的注意事项

  - 如何对数据的类型进行判断
  - 如何解决栈溢出的问题
  - 相同引用丢失
  - 如何解决循环引用的问题

- 实现方法

  ## JSON

  ```js
  // 缺点：无法对特殊的引用值如函数、正则等正确拷贝
  const cloned = JSON.parse(JSON.stringify(obj));
  ```

  ## 递归拷贝

  ```js
  // 数据判断用Object.prototype.toString()
  function getType(target) {
    const toStr = Object.prototype.toString;
    const typeList = {
      '[object Boolean]'  : 'boolean',
      '[object Number]'   : 'number',
      '[object String]'   : 'string',
      '[object Function]' : 'function',
      '[object Array]'    : 'array',
      '[object Date]'     : 'date',
      '[object RegExp]'   : 'regExp',
      '[object Map]'      : 'map',
      '[object Set]'      : 'set',
      '[object Undefined]': 'undefined',
      '[object Null]'     : 'null',
      '[object Object]'   : 'object'
    }
    return typeList[toStr.call(target)];
  }
  
  function deepClone(target) {
    const type = getType(target);
    let cloneTarget;
    if (type === 'array') {
      cloneTarget = [];
      target.forEach((item, i) => {
        cloneTarget[i] = deepClone(item);
      })
    }
    else if (type === 'object') {
      cloneTarget = {};
      Object.keys(target).forEach( key => {
        cloneTarget[key] = deepClone(target[key]);
      })
    } else {
      return target;
    }
    return cloneTarget;
  }
  
  
  ```

  

  ## 循环拷贝

  ```js
  // 1. 当拷贝层次比较深的时候，解决了栈溢出的问题
  // 用一个栈来收集引用值，等待下一次循环
  function cloneLoop(target) {
    const root = {};
    const stack = [
      {
        clone: root,
        target,
      }
    ]
    while (stack.length) {
      const { clone, target } = stack.pop();
      Object.keys(target).forEach(key => {
        if (getType(target[key]) === 'object') {
          stack.push({
            clone: clone[key] = {},
            target: target[key]
          })
        } else {
          clone[key] = target[key];
        }
      });
    }
    return root;
  }
  ```

  

  ## 破解引用丢失问题

  ```js
  function cloneForce(data) {
    const root = {};
    const stack = [
      {
        clone: root,
        data
      }
    ]
    // 用来保存已经拷贝的对象
    const uniqueList = [];
    while (stack.length) {
      let { clone, data } = stack.pop();
      // 查找是否有重复引用的对象，若有则直接赋值并跳出本轮循环
      const uniqueData = find(uniqueList, data);
      if (uniqueData) {
        clone = uniqueData.res;
        break;
      }
      // 数据不存在
      // 保存源数据，在拷贝数据中对应的引用
      uniqueList.push({
        res: clone,
        source: data,
      });
      Object.keys(data).forEach(key => {
        if (getType([key]) === 'object') {
          stack.push({
            clone: clone[key] = {},
            data: data[key]
          })
        } else {
          clone[key] = data[key];
        }
      });
    }
    return root;
  }
  
  function find(arr, target) {
    for (const item of arr) {
      if (item.source === target) {
        return item;
      }
    }
    return null;
  }
  ```
  
  ```js
  // 用上式可以解决循环引用问题
  const a = {
  	a,
  	b: 1,
  }
  const cloneA = cloneForce(a);
  // { a: undefined, b: 1 }
  ```
  
  