# 实例对象 && new操作符

## 对象是什么

1. 对象是单个实物的抽象。

2. 对象是一个容器，封装了属性（property）和方法（method）。

## 构造函数

1. 函数体内部使用了this关键字，代表了所要生成的对象实例。

2. 生成对象的时候，必须使用new命令。

## new命令

1. 为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式.严格模式中，函数内部的this不能指向全局对象，默认等于undefined.

2.  - 创建一个空对象，作为将要返回的对象实例。
    
    - 将这个空对象的原型，指向构造函数的prototype属性。
    
    - 将这个空对象赋值给函数内部的this关键字。
    
    - 开始执行构造函数内部的代码。

```javascript
    //1.忘加new ，this指向全局，price变成了全局变量
    var Vehicle = function (){
        this.price = 1000;
    };

    var v = Vehicle();
    v // undefined
    price // 1000

    //2.封装一个new操作符（new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。）
    function _new() {
        const args = [].slice.call(arguments);
        const constructor = args.shift();
        const obj = Object.create(constructor.prototype);
        const result = constructor.apply(obj,args);
        return ( result && typeof result == "object" ) ? result : obj;
    }

    //3.函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。
    function foo() {
        if(!new.target) {
            throw new Error("请使用new调用");
            
        }
    }
    foo();
```

# this 关键字

this都有一个共同点：它总是返回一个对象。

this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。

# 对象的继承

通过构造函数为实例对象定义属性有一个缺点：同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。

## instanceof 运算符  

返回一个布尔值，表示对象是否为某个构造函数的实例。

利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。

```javascript
    function Fubar (foo, bar) {
        if (this instanceof Fubar) {
            this._foo = foo;
            this._bar = bar;
        } else {
            return new Fubar(foo, bar);
        }
    }
```
## 原型链

原型链的尽头就是null。

如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。
```javascript
    Object.getPrototypeOf(Object.prototype);  //null

    //让构造函数的prototype属性指向一个数组，实例对象可以调用数组方法。
    var MyArray = function() {};
    MyArray.prototype = new Array();
    MyArray.prototype.constructor = MyArray;

    var mine = new MyArray();
```

## constructor 属性

修改原型对象时，一般要同时修改constructor属性的指向,要么只在原型对象上添加方法.

## instanceof 运算符

原理:检查右边构造函数的prototype属性，是否在左边对象的原型链上。

instanceof检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回true.

任意对象（除了null）都是Object的实例，instanceof运算符可以判断一个值是否为非null的对象。

```javascript
    function Vehicle() {};
    var v = new Vehicle();
    v instanceof Vehicle // true   相当于vehicle.prototype.isPrototypeof(v)

    v instanceof Object //true

    null instanceof Object//false

    Object.create(null) instanceof Object // false
```

## 构造函数的继承

第一步是在子类的构造函数中，调用父类的构造函数。
第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。
```javascript
    function Shape() {
        this.x = 0;
        this.y = 0;
    }
    Shape.prototype.move = function(x,y) {
        this.x += x;
        this.y += y;
        console.info("shape moved");
    }

    //1. 调用父类的构造函数。
    function Rectangle() {
        Shape.call(this);
    }
    //2. 承父类原型
    Rectangle.prototype = Object.create(Shape.prototype);
    Rectangle.prototype.constructor = Rectangle;

    var rec = new Rectangle();

    //单个方法的继承
    Rectangle.prototype.move = function() {
        Shape.prototype.move.call(this);
        //some code
    }
```
## 模块

 模块是实现特定功能的一组属性和方法的封装。

1. 所有的模块成员都放到这个对象里面。

2. 利用构造函数，封装私有变量。
这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。
构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则.


3. 使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。

```javascript
var module1 = (function () {
　 var _count = 0;
　 var m1 = function () {};
　 var m2 = function () {};
　 return {
　　 m1 : m1,
　　 m2 : m2
　 };
})();
```

4. 模块的放大模式
模块很大，必须分成几个部分，或者一个模块需要继承另一个模块

```javascript
    var module1 = (function(mod) {
        mod.m3 = function() {};
        return mod;
    })(module1);

    //宽放大模式：参数可以是空对象
    var module1 = (function(mod) {
        return mod;
    })(window.module1 || {});
```

5. 输入全局变量

模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入

立即执行函数还可以起到命名空间的作用。
finalCarousel对象输出到全局，对外暴露init和destroy接口.

```javascript
      (function($,YAHOO,window,document){
        function go(num) {}
        function handleEvents() {}
        function initialize() {}
        function dieCarouselDie() {}

        //attach to the global scope
        window.finalCarousel = {
            init : initialize,
            destroy : dieCarouselDie
        }
    })(jQuery,YAHOO,window,document);
```



# 严格模式

## 安全措施

1. 全局变量显式声明
2. 禁止 this 关键字指向全局对象
3. 禁止使用 fn.callee、fn.caller
4. 禁止使用 arguments.callee、arguments.caller
5. 禁止删除变量


## 原型和原型链

1. 所有对象都是由```new操作符```创建的

2. 所有的函数都是对象，所有函数也有属性和方法

### 原型prototype

1. 所有函数对象都有一个属性：prototype，叫做函数原型

2. 默认情况下，prototype指向一个普通的Object对象，该对象有一个属性constructor又指向构造函数本身。

### 隐式原型_proto_(在浏览器环境下使用，一般用Object.getPrototypeOf()方法取代)

所有对象都有一个属性```_proto_```,指向创建该对象的构造函数的原型。

### 原型链

特殊点：

1. Object构造函数的原型的原型为null;

2. Function构造函数的_proto_属性指向它的原型。

## 继承

1. 面向对象术语：子类继承父类的属性与方法，分为接口继承和实现继承

2. js继承实现：只有实现继承，以原型链为基础

3. 组合式继承模式

- 子类的实例通过子类的构造函数调用父类的构造函数实现

- 子类的方法通过原原型链使子类的原型指向父类的原型实现








